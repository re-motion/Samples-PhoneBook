<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Remotion.Interfaces</name>
    </assembly>
    <members>
        <member name="T:Remotion.AdapterRegistry">
            <summary>Used to register <see cref="T:Remotion.IAdapter"/> instances.</summary>
            <remarks>Used by those modules of the framework that do not have binary depedencies to another module to access information from this module.</remarks>
        </member>
        <member name="T:Remotion.BridgeInterfaces.IInterlockedCacheFactoryImplementation">
            <summary>
            This interface is used to separate the <see cref="T:Remotion.BridgeImplementations.InterlockedCacheFactoryImplementation"/>
            from it's instantiation in the current service locator.
            </summary>
        </member>
        <member name="T:Remotion.BridgeInterfaces.ITypeDiscoveryServiceFactoryImplementation">
            <summary>
            This interface is used to separate the <see cref="T:Remotion.BridgeImplementations.TypeDiscoveryServiceFactoryImplementation"/>
            from it's instantiation in the current service locator.
            </summary>
        </member>
        <member name="T:Remotion.Context.ISafeContextStorageProvider">
            <summary>
            Common interface for classes implementing a storage mechanism for <see cref="T:Remotion.Context.SafeContext"/>.
            </summary>
        </member>
        <member name="M:Remotion.Context.ISafeContextStorageProvider.GetData(System.String)">
            <summary>
            Retrieves a data item from the context storage.
            </summary>
            <param name="key">The key identifying the data item.</param>
            <returns>The data item identified by the given key, or <see langword="null"/> if no such item exists in the storage.</returns>
        </member>
        <member name="M:Remotion.Context.ISafeContextStorageProvider.SetData(System.String,System.Object)">
            <summary>
            Sets a data item in the context storage, overwriting a previous value identified by the same key.
            </summary>
            <param name="key">The key identifying the data item.</param>
            <param name="value">The value to be stored in the context storage.</param>
        </member>
        <member name="M:Remotion.Context.ISafeContextStorageProvider.FreeData(System.String)">
            <summary>
            Frees the resources used by a specific data item in the context storage.
            </summary>
            <param name="key">The key identifying the data item to be freed.</param>
        </member>
        <member name="T:Remotion.Collections.ICache`2">
            <summary>
            Provides a comnmon interface for caches, which provide efficient storage and retrieval for values that are costly to calculate.
            </summary>
            <typeparam name="TKey">The key type via which values should be indexed.</typeparam>
            <typeparam name="TValue">The type of the values to be stored in the cache.</typeparam>
            <remarks>
            Caches are only meant for performance improvement, they are not reliable data containers. Do not rely on values being present in the cache;
            caches might choose to remove individual items (or all their items) at any time. If a reliable store is needed, use 
            <see cref="T:System.Collections.Generic.IDictionary`2"/> or <see cref="T:Remotion.Collections.IDataStore`2"/>.
            </remarks>
        </member>
        <member name="T:Remotion.INullObject">
            <summary>
            Represents a nullable object according to the "Null Object Pattern".
            </summary>
        </member>
        <member name="P:Remotion.INullObject.IsNull">
            <summary>
            Gets a value indicating whether the object is a "Null Object".
            </summary>
        </member>
        <member name="T:Remotion.Collections.IDataStore`2">
            <summary>
            Provides a common interface for data structures used for storing and retrieving key/value pairs.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
            <remarks>
            <para>
            This interface is basically a simplified version of the <see cref="T:System.Collections.Generic.IDictionary`2"/> interface. In contrast to 
            <see cref="T:System.Collections.Generic.IDictionary`2"/>, it does not require implementers to support <see cref="T:System.Collections.Generic.IEnumerable`1"/>, <see cref="T:System.Collections.Generic.ICollection`1"/>,
            etc, so it is much simpler to implement.
            </para>
            <para>
            Use this in place of <see cref="T:Remotion.Collections.ICache`2"/> if you need a reliable data store which guarantees to keep values once inserted until
            they are removed.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Collections.IDataStore`2.ContainsKey(`0)">
            <summary>
            Determines whether the store contains an element with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key to look up.</param>
            <returns>
            true if the store contains the specified key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Remotion.Collections.IDataStore`2.Add(`0,`1)">
            <summary>
            Adds a new element to the store.
            </summary>
            <param name="key">The key of the new element.</param>
            <param name="value">The value of the new element.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">An item with an equal key already exists in the store.</exception>
        </member>
        <member name="M:Remotion.Collections.IDataStore`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the store, if any.
            </summary>
            <param name="key">The key of the element to be removed.</param>
            <returns>true if the item was found in the store; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Remotion.Collections.IDataStore`2.Clear">
            <summary>
            Removes all elements from the store.
            </summary>
        </member>
        <member name="M:Remotion.Collections.IDataStore`2.GetValueOrDefault(`0)">
            <summary>
            Gets the value of the element with the specified key, or <typeparamref name="TValue"/>'s default value if no such element exists.
            </summary>
            <param name="key">The key to look up.</param>
            <returns>The value of the element, or the default value if no such element exists.</returns>
        </member>
        <member name="M:Remotion.Collections.IDataStore`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value of the element with the specified key.
            </summary>
            <param name="key">The key to look up.</param>
            <param name="value">The value of the element with the specified key, or <typeparamref name="TValue"/>'s default value if no such element 
            exists.</param>
            <returns>true if an element with the specified key was found; otherwise, false.</returns>
        </member>
        <member name="M:Remotion.Collections.IDataStore`2.GetOrCreateValue(`0,System.Func{`0,`1})">
            <summary>
            Gets the value of the element with the specified key, creating a new one if none exists.
            </summary>
            <param name="key">The key of the element to be retrieved.</param>
            <param name="creator">A delegate used for creating a new element if none exists.</param>
            <returns>The value of the element that was found or created.</returns>
        </member>
        <member name="P:Remotion.Collections.IDataStore`2.Item(`0)">
            <summary>
            Gets or sets the value of the element with the specified key.
            </summary>
            <value>The value of the element.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The element whose value should be retrieved could not be found.</exception>
        </member>
        <member name="T:Remotion.Context.SafeContext">
            <summary>
            Superior alternative to the <see cref="T:System.ThreadStaticAttribute"/> and <see cref="T:System.Runtime.Remoting.Messaging.CallContext"/> for making member variables thread safe that 
            also works with ASP.NET threads.
            </summary>
            <remarks>
            <para>
            The data managed by this class is by default stored in the <see cref="T:System.Runtime.Remoting.Messaging.CallContext"/>, but the storage provider can be replaced by application 
            code if needed. Replacements for the storage provider must guarantee that all data stored by the <see cref="T:Remotion.Context.SafeContext"/> is thread-local.
            </para>
            <para>
            The Remotion.Web assembly by default replaces the storage provider with one that stores all data in the <see cref="O:System.Web.HttpContext"/>. 
            This ensures that <see cref="T:Remotion.Context.SafeContext"/> works as expected in ASP.NET environments when a session migrates between threads.
            </para>
            </remarks>
            <threadsafety>
            The data managed by this class is thread-local. The class is safe to be used from multiple threads at the same time, but each thread will have 
            its own copy of the data.
            </threadsafety>
        </member>
        <member name="M:Remotion.Context.SafeContext.GetDefaultInstance">
            <summary>
            Gets or creates the default instance to be used when the <see cref="T:Remotion.Context.SafeContext"/> is initialized.
            </summary>
            <returns>The default storage instance for this <see cref="T:Remotion.Context.SafeContext"/>.</returns>
            <remarks>
            <para>
            This method can be overridden by a mixin in order to change the default <see cref="P:Remotion.Context.SafeContext.Instance"/>. While this method is executed,
            a temporary default <see cref="T:System.Runtime.Remoting.Messaging.CallContext"/>-based storage provider is set active. Therefore, code executed from within
            <see cref="M:Remotion.Context.SafeContext.GetDefaultInstance"/> can safely access <see cref="P:Remotion.Context.SafeContext.Instance"/> without causing a stack overflow.
            </para>
            <para>
            However, the fact that it is temporary means that the data written into the context will not be available after <see cref="P:Remotion.Context.SafeContext.Instance"/>
            has been initialized (unless the new instance is also based on the <see cref="T:System.Runtime.Remoting.Messaging.CallContext"/>). This also means that it is not possible to
            imperatively prepare a certain mixin configuration before the <see cref="T:Remotion.Context.SafeContext"/> is initialized; only the mixins present in the
            default mixin configuration will be considered for overriding this method.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Design.IDesignModeHelper">
            <summary>
            The <see cref="T:Remotion.Design.IDesignModeHelper"/> interface defines methods to encapsulate the access to various design-mode properties of a project.
            It is intended to be used by components offering design-time support.
            </summary>
        </member>
        <member name="T:Remotion.IAdapter">
            <summary>
            Marker interface, used as type parameter for the <see cref="M:Remotion.BridgeInterfaces.IAdapterRegistryImplementation.SetAdapter(System.Type,Remotion.IAdapter)"/> and 
            <see cref="M:Remotion.BridgeInterfaces.IAdapterRegistryImplementation.GetAdapter``1"/> methods of <see cref="T:Remotion.AdapterRegistry"/>.
            </summary>
        </member>
        <member name="T:Remotion.Implementation.ConcreteImplementationAttribute">
            <summary>
            Defines the concrete implementation for a service type (usually an interface or abstract class) as well as its <see cref="T:Remotion.Implementation.LifetimeKind"/>.
            This attribute is used by the DefaultServiceProvider to determine how to instantiate a service type. The 
            <see cref="T:Remotion.Implementation.ConcreteImplementationAttribute"/> can only be used once per service type, and it is not inherited.
            </summary>
        </member>
        <member name="M:Remotion.Implementation.ConcreteImplementationAttribute.#ctor(System.String)">
            <summary>
            Defines a concrete implementation for a service type by means of a type name template. The template can contain placeholders such as
            "&lt;version&gt;" and "&lt;publicKeyToken&gt;" that are replaced with the version and public key token of the re-motion assemblies when
            the type is resolved. See <see cref="T:Remotion.Implementation.TypeNameTemplateResolver"/> for details.
            </summary>
            <param name="typeNameTemplate">
            A type name indicating the concrete implementation for the service type, optionally containing placeholders.
            </param>
        </member>
        <member name="M:Remotion.Implementation.ConcreteImplementationAttribute.#ctor(System.Type)">
            <summary>
            Defines a concrete implementation for a service type.
            </summary>
            <param name="type">The type representing the concrete implementation for the service type.</param>
        </member>
        <member name="P:Remotion.Implementation.ConcreteImplementationAttribute.TypeNameTemplate">
            <summary>
            Gets the type name template for the concrete implementation type. The template can contain placeholders and can be resolved using the
            <see cref="T:Remotion.Implementation.TypeNameTemplateResolver"/> class.
            </summary>
            <value>The type name template.</value>
        </member>
        <member name="P:Remotion.Implementation.ConcreteImplementationAttribute.Lifetime">
            <summary>
            Gets or sets the lifetime of instances of the concrete implementation type. The lifetime is used by service locators to control when to reuse 
            instances of the concrete implementation type and when to create new ones. The default value is <see cref="F:Remotion.Implementation.LifetimeKind.Instance"/>.
            </summary>
            <value>The lifetime of instances of the concrete implementation type.</value>
        </member>
        <member name="T:Remotion.Implementation.TypeNameTemplateResolver">
            <summary>
            Provides functionality to resolve type name templates to actual types. Type name templates are assembly-qualified type names that contain
            "&lt;version&gt;" and "&lt;publicKeyToken&gt;" as placeholders for version and public key token. Those placeholders will be replaced with
            the <see cref="T:Remotion.Implementation.FrameworkVersion"/> and the public key token of the re-motion framework, then <see cref="T:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility"/> is
            used to resolve the type.
            </summary>
        </member>
        <member name="T:Remotion.Implementation.FrameworkVersion">
            <summary>
            Holds the <see cref="T:System.Version"/> object used by <see cref="T:Remotion.Implementation.TypeNameTemplateResolver"/> to retrieve types from
            the re-motion implementation assemblies.
            </summary>
        </member>
        <member name="M:Remotion.Implementation.FrameworkVersion.Reset">
            <summary>
            Resets the version information so that the next retrieval of <see cref="P:Remotion.Implementation.FrameworkVersion.Value"/> will trigger an automatic resolution. After calling this
            method, <see cref="P:Remotion.Implementation.FrameworkVersion.Value"/> can be used to set a different <see cref="T:System.Version"/> value.
            </summary>
        </member>
        <member name="M:Remotion.Implementation.FrameworkVersion.RetrieveFromType(System.Type)">
            <summary>
            Retrieves from version information from the assembly defining the given type. This is a shortcut for the following statemnt:
            <code>Value = frameworkType.Assembly.GetName ().Version;</code>
            </summary>
            <param name="frameworkType">A framework type to retrieve the version from.</param>
        </member>
        <member name="P:Remotion.Implementation.FrameworkVersion.Value">
            <summary>
            Gets or sets the framework version value.
            </summary>
            <value>The framework version value. If none has been set, the getter will attempt to retrieve the version automatically (and throw
            an exception if it cannot do so). When one version has been set, no other version can be set unless <see cref="M:Remotion.Implementation.FrameworkVersion.Reset"/> is called before.
            (The same version can be set without an exception being thrown.)</value>
        </member>
        <member name="T:Remotion.Implementation.FrameworkVersionNotFoundException">
            <summary>
            Thrown by <see cref="T:Remotion.Implementation.FrameworkVersionRetriever"/> when the framework version cannot be determined automatically. Use 
            <see cref="T:Remotion.Implementation.FrameworkVersion"/> to manually set the version or add a reference to the framework implementation assembly.
            </summary>
        </member>
        <member name="T:Remotion.Implementation.LifetimeKind">
            <summary>
            Defines the lifetime of instances of a type managed by a service locator.
            </summary>
        </member>
        <member name="F:Remotion.Implementation.LifetimeKind.Singleton">
            <summary>
            One instance is created and then reused every time an instance of the type is requested. This is the most efficient 
            <see cref="T:Remotion.Implementation.LifetimeKind"/>, and it should be used whenever possible. However, in cases where the service locator is used from multiple threads,
            the <see cref="F:Remotion.Implementation.LifetimeKind.Singleton"/> lifetime kind requires the instantiated type to be safe for multi-threading. Use <see cref="F:Remotion.Implementation.LifetimeKind.Instance"/> when an
            implementation is not thread-safe.
            </summary>
        </member>
        <member name="F:Remotion.Implementation.LifetimeKind.Instance">
            <summary>
            A new instance is created every time an instance of the type is requested. This is the simplest <see cref="T:Remotion.Implementation.LifetimeKind"/> and works
            well even in multi-threaded environments, but it might not be the most efficient one. Use <see cref="F:Remotion.Implementation.LifetimeKind.Singleton"/> for more efficiency.
            </summary>
        </member>
        <member name="M:Remotion.Logging.BridgeInterfaces.ILogManagerImplementation.GetLogger(System.String)">
            <summary>
            Gets or creates a logger.
            </summary>
            <param name="name">The name of the logger to retrieve.</param>
            <returns>A logger for the <paramref name="name"/> specified.</returns>
        </member>
        <member name="M:Remotion.Logging.BridgeInterfaces.ILogManagerImplementation.GetLogger(System.Type)">
            <summary>
            Gets or creates a logger.
            </summary>
            <param name="type">The full name of <paramref name="type"/> will be used as the name of the logger to retrieve.</param>
            <returns>A logger for the fully qualified name of the <paramref name="type"/> specified.</returns>
        </member>
        <member name="M:Remotion.Logging.BridgeInterfaces.ILogManagerImplementation.Initialize">
            <summary>
            Initializes the current logging framework.
            </summary>
        </member>
        <member name="M:Remotion.Logging.BridgeInterfaces.ILogManagerImplementation.InitializeConsole">
            <summary>
            Initializes the current logging framework to log to the console.
            </summary>
        </member>
        <member name="T:Remotion.Logging.ILog">
            <summary>
            The <see cref="T:Remotion.Logging.ILog"/> interface declares methods for logging messages.
            </summary>
            <remarks>
        The <see cref="T:Remotion.Logging.ILog"/> interface is intended for implementing adapters to various logging frameworks.
      <note>
        The range of valid event ids is only guarenteed within the range of unsigned 16-bit integers.
      </note>
      <note type="inheritinfo">
        Implementors must support event ids within the range of unsigned 16-bit integers. The behavior outside this range is can be either truncation 
        of the event id or an <see cref="T:System.ArgumentOutOfRangeException"/>. Implementors must ensure that the log message is logged before an 
        <see cref="T:System.ArgumentOutOfRangeException"/> is thrown.
      </note>
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.Log(Remotion.Logging.LogLevel,System.Int32,System.Object,System.Exception)">
            <overloads>Log a message object with the specified <paramref name="logLevel"/>.</overloads>
            <summary>
            Log a message object with the specified <paramref name="logLevel"/> and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Log(Remotion.Logging.LogLevel,System.Int32,System.Object)">
            <summary>
            Log a message object with the specified <paramref name="logLevel"/> and <paramref name="eventID"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Log(Remotion.Logging.LogLevel,System.Object,System.Exception)">
            <summary>
            Log a message object with the specified <paramref name="logLevel"/>,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Log(Remotion.Logging.LogLevel,System.Object)">
            <summary>
            Log a message object with the specified <paramref name="logLevel"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.LogFormat(Remotion.Logging.LogLevel,System.Int32,System.Exception,System.String,System.Object[])">
            <overloads>Log a formatted string with the specified <paramref name="logLevel"/>.</overloads>
            <summary>
            Log a formatted string with the specified <paramref name="logLevel"/> and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="eventID">The numeric identifier for the event.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.LogFormat(Remotion.Logging.LogLevel,System.Int32,System.String,System.Object[])">
            <summary>
            Log a formatted string with the specified <paramref name="logLevel"/> and <paramref name="eventID"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="eventID">The numeric identifier for the event.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.LogFormat(Remotion.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Log a formatted string with the specified <paramref name="logLevel"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.LogFormat(Remotion.Logging.LogLevel,System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string with the specified <paramref name="logLevel"/>,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.LogFormat(Remotion.Logging.LogLevel,System.Enum,System.Exception,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the specified <paramref name="logLevel"/>, including the stack 
            trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.LogFormat(Remotion.Logging.LogLevel,System.Enum,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the specified <paramref name="logLevel"/>.
            </summary>
            <param name="logLevel">The <see cref="T:Remotion.Logging.LogLevel"/> of the message to be logged.</param>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.Debug(System.Int32,System.Object,System.Exception)">
            <overloads>Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level.</overloads>
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Debug(System.Int32,System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Debug(System.Object,System.Exception)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Debug(System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level.
            </summary>
            <param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.DebugFormat(System.Int32,System.Exception,System.String,System.Object[])">
            <overloads>Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level.</overloads>
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.DebugFormat(System.Int32,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.DebugFormat(System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level.
            </summary>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.DebugFormat(System.Enum,System.Exception,System.Object[])">
            <summary>
            Log message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level, including the stack 
            trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.DebugFormat(System.Enum,System.Object[])">
            <summary>
            Log message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level.
            </summary>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.Info(System.Int32,System.Object,System.Exception)">
            <overloads>Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level.</overloads>
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Info(System.Int32,System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Info(System.Object,System.Exception)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Info(System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level.
            </summary>
            <param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.InfoFormat(System.Int32,System.Exception,System.String,System.Object[])">
            <overloads>Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level.</overloads>
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.InfoFormat(System.Int32,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.InfoFormat(System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level.
            </summary>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.InfoFormat(System.Enum,System.Exception,System.Object[])">
            <summary>
            Log message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level, including the stack 
            trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.InfoFormat(System.Enum,System.Object[])">
            <summary>
            Log message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Info"/> level.
            </summary>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.Warn(System.Int32,System.Object,System.Exception)">
            <overloads>Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level.</overloads>
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Warn(System.Int32,System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Warn(System.Object,System.Exception)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Warn(System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level.
            </summary>
            <param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.WarnFormat(System.Int32,System.Exception,System.String,System.Object[])">
            <overloads>Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level.</overloads>
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.WarnFormat(System.Int32,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.WarnFormat(System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level.
            </summary>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.WarnFormat(System.Enum,System.Exception,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level, including the stack 
            trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.WarnFormat(System.Enum,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level.
            </summary>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.Error(System.Int32,System.Object,System.Exception)">
            <overloads>Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level.</overloads>
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Error(System.Int32,System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Error(System.Object,System.Exception)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Error(System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level.
            </summary>
            <param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.ErrorFormat(System.Int32,System.Exception,System.String,System.Object[])">
            <overloads>Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level.</overloads>
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.ErrorFormat(System.Int32,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level.
            </summary>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.ErrorFormat(System.Enum,System.Exception,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level, including the stack 
            trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.ErrorFormat(System.Enum,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Error"/> level.
            </summary>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.Fatal(System.Int32,System.Object,System.Exception)">
            <overloads>Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level.</overloads>
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Fatal(System.Int32,System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Fatal(System.Object,System.Exception)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="message">The message object to log.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.Fatal(System.Object)">
            <summary>
            Log a message object with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level.
            </summary>
            <param name="message">The message object to log.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.FatalFormat(System.Int32,System.Exception,System.String,System.Object[])">
            <overloads>Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level.</overloads>
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level and <paramref name="eventID"/>,
            including the stack trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param><param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.FatalFormat(System.Int32,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level and <paramref name="eventID"/>.
            </summary>
            <param name="eventID">The numeric identifier for the event.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.FatalFormat(System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level.
            </summary>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level,
            including the stack trace of <paramref name="exceptionObject"/>. 
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="format">A String containing zero or more format items.</param><param name="args">An Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:Remotion.Logging.ILog.FatalFormat(System.Enum,System.Exception,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level, including the stack 
            trace of <paramref name="exceptionObject"/>.
            </summary>
            <param name="exceptionObject">The <see cref="T:System.Exception"/> to log, including its stack trace. Pass <see langword="null"/> to not log an exception.</param>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.FatalFormat(System.Enum,System.Object[])">
            <summary>
            Log a message and event id derived from the <paramref name="messageEnum"/> with the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level.
            </summary>
            <param name="messageEnum">
      An <see cref="T:System.Enum"/> value that is used to supply the event id and the message or format string. Must not be <see langword="null"/>.
    </param><param name="args">An Object array containing zero or more objects to format.</param>
            <remarks>
      The underlying <see cref="T:System.Int32"/> value of the <paramref name="messageEnum"/> is used as event id. 
      Use <see cref="T:Remotion.Utilities.EnumDescriptionAttribute"/> or <see cref="T:Remotion.Utilities.EnumDescriptionResourceAttribute"/> 
      to associate messages with the enum values.
    </remarks>
        </member>
        <member name="M:Remotion.Logging.ILog.IsEnabled(Remotion.Logging.LogLevel)">
            <summary>
            Checks if this logger is enabled for the given <see cref="T:Remotion.Logging.LogLevel"/>.
            </summary>
            <param name="logLevel">The log level to check for.</param>
            <returns>
              <see langword="true"/> if the specified log level is enabled; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="P:Remotion.Logging.ILog.IsDebugEnabled">
            <summary>
            Checks if this logger is enabled for the <see cref="F:Remotion.Logging.LogLevel.Debug"/> level.
            </summary>
        </member>
        <member name="P:Remotion.Logging.ILog.IsInfoEnabled">
            <summary>
            Checks if this logger is enabled for the <see cref="F:Remotion.Logging.LogLevel.Info"/> level.
            </summary>
        </member>
        <member name="P:Remotion.Logging.ILog.IsWarnEnabled">
            <summary>
            Checks if this logger is enabled for the <see cref="F:Remotion.Logging.LogLevel.Warn"/> level.
            </summary>
        </member>
        <member name="P:Remotion.Logging.ILog.IsErrorEnabled">
            <summary>
            Checks if this logger is enabled for the <see cref="F:Remotion.Logging.LogLevel.Error"/> level.
            </summary>
        </member>
        <member name="P:Remotion.Logging.ILog.IsFatalEnabled">
            <summary>
            Checks if this logger is enabled for the <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level.
            </summary>
        </member>
        <member name="T:Remotion.Logging.ILogManager">
            <summary>
            The <see cref="T:Remotion.Logging.ILogManager"/> interface declares the methods available for retrieving a logger that implements
            <see cref="T:Remotion.Logging.ILog"/> and initializing the respective logging framework.
            </summary>
        </member>
        <member name="M:Remotion.Logging.ILogManager.GetLogger(System.String)">
            <summary>
            Gets or creates a logger.
            </summary>
            <param name="name">The name of the logger to retrieve.</param>
            <returns>A logger for the <paramref name="name"/> specified.</returns>
        </member>
        <member name="M:Remotion.Logging.ILogManager.GetLogger(System.Type)">
            <summary>
            Gets or creates a logger.
            </summary>
            <param name="type">The full name of <paramref name="type"/> will be used as the name of the logger to retrieve.</param>
            <returns>A logger for the fully qualified name of the <paramref name="type"/> specified.</returns>
        </member>
        <member name="M:Remotion.Logging.ILogManager.Initialize">
            <summary>
            Initializes the logging framework abstracted through the <see cref="T:Remotion.Logging.ILogManager"/> interface.
            </summary>
        </member>
        <member name="M:Remotion.Logging.ILogManager.InitializeConsole">
            <summary>
            Initializes the logging framework to log to the console.
            </summary>
        </member>
        <member name="T:Remotion.Logging.LogLevel">
            <summary>
            Defines the log levels available when logging through the <see cref="T:Remotion.Logging.ILog"/> interface.
            </summary>
        </member>
        <member name="F:Remotion.Logging.LogLevel.Debug">
            <summary>
            The <see cref="F:Remotion.Logging.LogLevel.Debug"/> level designates fine-grained informational events that are most useful to debug an application.
            </summary>
        </member>
        <member name="F:Remotion.Logging.LogLevel.Info">
            <summary>
            The <see cref="F:Remotion.Logging.LogLevel.Info"/> level designates informational messages that highlight the progress of the application at coarse-grained level. 
            </summary>
        </member>
        <member name="F:Remotion.Logging.LogLevel.Warn">
            <summary>
            The <see cref="F:Remotion.Logging.LogLevel.Warn"/> level designates potentially harmful situations.
            </summary>
        </member>
        <member name="F:Remotion.Logging.LogLevel.Error">
            <summary>
            The <see cref="F:Remotion.Logging.LogLevel.Error"/> level designates error events that might still allow the application to continue running. 
            </summary>
        </member>
        <member name="F:Remotion.Logging.LogLevel.Fatal">
            <summary>
            The <see cref="F:Remotion.Logging.LogLevel.Fatal"/> level designates very severe error events that will presumably lead the application to abort.
            </summary>
        </member>
        <member name="T:Remotion.Logging.LogManager">
            <summary>
            Use this class to create a logger implementing <see cref="T:Remotion.Logging.ILog"/> from the current <see cref="T:Remotion.Logging.ILogManager"/>.
            </summary>
            <remarks>
            Currently only <b>log4net</b> is supported as logging infrastructure.
            </remarks>
        </member>
        <member name="M:Remotion.Logging.LogManager.GetLogger(System.String)">
            <summary>
            Gets or creates a logger.
            </summary>
            <param name="name">The name of the logger to retrieve.</param>
            <returns>A logger for the <paramref name="name"/> specified.</returns>
        </member>
        <member name="M:Remotion.Logging.LogManager.GetLogger(System.Type)">
            <summary>
            Gets or creates a logger.
            </summary>
            <param name="type">The full name of <paramref name="type"/> will be used as the name of the logger to retrieve.</param>
            <returns>A logger for the fully qualified name of the <paramref name="type"/> specified.</returns>
        </member>
        <member name="M:Remotion.Logging.LogManager.Initialize">
            <summary>
            Initializes the current logging framework.
            </summary>
        </member>
        <member name="M:Remotion.Logging.LogManager.InitializeConsole">
            <summary>
            Initializes the current logging framework to log to the console.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.AcceptsAlphabeticOrderingAttribute">
            <summary>
            Indicates that an ordinal name comparison can be used to determine the order between two mixins when these override the same methods
            on a target object. Only use this if you don't care about the actual mixin order.
            </summary>
            <remarks>
            <para>
            Ordering between mixins is important when two mixins override the same methods on a target object, because without a defined ordering,
            it wouldn't be deterministic which of the overrides would be executed first. Usually, orderings between mixins are expressed via dependencies.
            Either implicitly, because the mixin has a base call dependency (second type argument of the <see cref="T:Remotion.Mixins.Mixin`2"/> base class) to 
            an interface implemented by another mixin, or explicitly via  <see cref="P:Remotion.Mixins.MixinRelationshipAttribute.AdditionalDependencies"/>.
            </para>
            <para>
            In some situations, however, a mixin cannot and does not need to specify a specific ordering simply because any override call order would
            be sufficient for its purpose. Such a mixin can opt into alphabetic ordering by having this attribute applied to it. Alphabetic ordering is
            only applied after all implicit or explicit dependencies have been analyzed. It is also ruled out if two or more of the mixins involved
            do not accept alphabetic ordering.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.BindToTargetTypeAttribute">
            <summary>
            Indicates that a generic parameter of a mixin should be bound to the mixin's target type (unless the generic parameter type is explicitly
            specified when the mixin is configured).
            </summary>
            <remarks>
            <para>
            Apply this attribute to a generic parameter of a generic mixin when the mixin engine should be able to automatically close the mixin type.
            Without the attribute, an exception will be thrown.
            </para>
            <para>
            For example, consider the following code:
            <code>
            public class TargetClass&lt;T&gt; { }
            
            [Extends (typeof (TargetClass&lt;&gt;))]
            public class MyMixin&lt;T&gt; { }
            </code>
            To bind <c>T</c> to <c>TargetClass&lt;T&gt;</c>, use a binding specification:
            <code>
            public class TargetClass&lt;T&gt; { }
            
            [Extends (typeof (TargetClass&lt;&gt;))]
            public class MyMixin&lt;[BindToTargetType] T&gt; { }
            </code>
            </para>
            <note type="inotes">When a type parameter is reused for the generic parameter of the <see cref="T:Remotion.Mixins.Mixin`2"/>
            or <see cref="T:Remotion.Mixins.Mixin`1"/> base classes, the type parameter must satisfy several constraints. See <see cref="T:Remotion.Mixins.Mixin`2"/> and
            <see cref="T:Remotion.Mixins.Mixin`1"/> for more information.</note>
            </remarks>
            <seealso cref="T:Remotion.Mixins.BindToConstraintsAttribute"/>
            <seealso cref="T:Remotion.Mixins.BindToGenericTargetParameterAttribute"/>
        </member>
        <member name="T:Remotion.Mixins.CompleteInterfaceAttribute">
            <summary>
            Indicates that an interface acts as a complete interface for a class instantiated via <see cref="T:Remotion.Mixins.ObjectFactory"/>.
            </summary>
            <remarks>
            <para>
            A complete interface combines the API of a target type with that of its mixins. For example, if a target class provides the methods A and B
            and a mixin adds the methods C and D, users of the class could normally only use either A and B or C and D at the same time (without casting).
            By implementing a complete interface that provides methods A, B, C, and D, users of the class can employ the full API in a simple way.
            </para>
            <para>
            All methods specified by a complete interface must either be implemented on the target type or introduced via a mixin.
            </para>
            <para>
            This interface can be applied multiple times if an interface is to be a complete interface for multiple target types. The attribute is not
            inherited, i.e. an interface inheriting from a complete interface does not automatically constitute a complete interface as well.
            </para>
            <para>
            When the default mixin configuration is built via analysis of the declarative attributes, all complete interfaces
            are automatically registered with the active mixin configuration. This means that in the default mixin configuration,
            <see cref="M:Remotion.Mixins.ObjectFactory.Create``1(Remotion.Reflection.ParamList,System.Object[])"/> will be able to create instances from these
            interfaces.
            </para>
            </remarks>
            <example>
            <code>
            public class MyMixinTarget
            {
              public void A() { Console.WriteLine ("A"); }
              public void B() { Console.WriteLine ("B"); }
            }
            
            [Extends (typeof (MyMixinTarget))]
            public class MyMixin : Mixin&lt;MyMixinTarget&gt;
            {
              public void C() { Console.WriteLine ("D"); }
              public void D() { Console.WriteLine ("D"); }
            }
            
            [CompleteInterface (typeof (MyMixinTarget))]
            public interface ICMyMixinTargetMyMixin
            {
              void A();
              void B();
              void C();
              void D();
            }
            </code>
            Complete interfaces can also be defined by inheriting from existing interfaces rather than spelling all the methods out explicitly.
            </example>
        </member>
        <member name="M:Remotion.Mixins.CompleteInterfaceAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/> class.
            </summary>
            <param name="targetType">Target type for which this interface constitutes a complete interface.</param>
        </member>
        <member name="P:Remotion.Mixins.CompleteInterfaceAttribute.TargetType">
            <summary>
            Gets the target tyoe for which this interface constitutes a complete interface.
            </summary>
            <value>The target type of this complete interface.</value>
        </member>
        <member name="T:Remotion.Mixins.BindToConstraintsAttribute">
            <summary>
            Indicates that a generic parameter of a mixin should be bound to a type inferred from the type parameter's generic constraints 
            (unless the generic parameter type is explicitly specified when the mixin is configured).
            </summary>
            <remarks>
            <para>
            Apply this attribute to a generic parameter of a generic mixin when the mixin engine should be able to automatically close the mixin type.
            Without the attribute, an exception will be thrown.
            </para>
            <para>
            For example, consider the following code:
            <code>
            public class TargetClass&lt;T&gt; : ITargetClass { }
            
            [Extends (typeof (TargetClass&lt;&gt;))]
            public class MyMixin&lt;T&gt; where T : ITargetClass { }
            </code>
            To bind <c>T</c> to <c>ITargetClass</c>, use a binding specification:
            <code>
            public class TargetClass&lt;T&gt; : ITargetClass { }
            
            [Extends (typeof (TargetClass&lt;&gt;))]
            public class MyMixin&lt;[BindToConstraints]T&gt; where T : ITargetClass { }
            </code>
            </para>
            <para>
            <list type="bullet">
            <item>
            When there are no constraint or there is only a <c>class</c> constraint, the generic parameter is bound to <see cref="T:System.Object"/>.
            </item>
            <item>
            When there is only a struct constraint, the generic parameter is bound to <see cref="T:System.Int32"/>.
            </item>
            <item>
            When there are multiple interface, type, struct, and class constraints that cannot be unified into a single type, an exception is thrown.
            </item>
            </list>
            </para>
            <note type="inotes">When a type parameter is reused for the generic parameter of the <see cref="T:Remotion.Mixins.Mixin`2"/>
            or <see cref="T:Remotion.Mixins.Mixin`1"/> base classes, the type parameter must satisfy several constraints. See <see cref="T:Remotion.Mixins.Mixin`2"/> and
            <see cref="T:Remotion.Mixins.Mixin`1"/> for more information.</note>
            </remarks>
            <seealso cref="T:Remotion.Mixins.BindToTargetTypeAttribute"/>
            <seealso cref="T:Remotion.Mixins.BindToGenericTargetParameterAttribute"/>
        </member>
        <member name="T:Remotion.Mixins.BindToGenericTargetParameterAttribute">
            <summary>
            Indicates that a generic parameter of a mixin should be bound to the mixin's target type's generic parameter (unless the generic parameter 
            type is explicitly specified when the mixin is configured). Generic parameters with this attribute must be at the front of a mixin's generic
            parameter list, and they are mapped to the generic parameter of the target type by position.
            </summary>
            <remarks>
            <para>
            For example, consider the following code:
            <code>
            public class TargetClass&lt;T&gt; { }
            
            [Extends (typeof (TargetClass&lt;&gt;))]
            public class MyMixin&lt;[BindToGenericTargetParameter]T&gt; { }
            </code>
            To bind MyMixin's <c>T</c> to the <c>&lt;T&gt;</c> parameter of TargetClass, use the following code:
            <code>
            public class TargetClass&lt;T&gt; { }
            
            [Extends (typeof (TargetClass&lt;&gt;))]
            public class MyMixin&lt;[BindToGenericTargetParameter] T&gt; { }
            </code>
            </para>
            <note type="inotes">When a type parameter is reused for the generic parameter of the <see cref="T:Remotion.Mixins.Mixin`2"/>
            or <see cref="T:Remotion.Mixins.Mixin`1"/> base classes, the type parameter must satisfy several constraints. See <see cref="T:Remotion.Mixins.Mixin`2"/> and
            <see cref="T:Remotion.Mixins.Mixin`1"/> for more information.</note>
            </remarks>
            <seealso cref="T:Remotion.Mixins.BindToTargetTypeAttribute"/>
            <seealso cref="T:Remotion.Mixins.BindToConstraintsAttribute"/>
        </member>
        <member name="T:Remotion.Mixins.ComposedObject`1">
            <summary>
            Acts as a convenience base class for domain objects in the mixin-based composition pattern. Provides a <see cref="P:Remotion.Mixins.ComposedObject`1.This"/> property that 
            allows access to the composed interface, and a <see cref="M:Remotion.Mixins.ComposedObject`1.NewObject``1(Remotion.Reflection.ParamList)"/> factory method for subclasses.
            </summary>
            <typeparam name="TComposedInterface">The composed interface of the derived class. This interface defines the members available via
            the <see cref="P:Remotion.Mixins.ComposedObject`1.This"/> property. See the Remarks section for details. Each composed interface can only be associated with one single subclass
            of <see cref="T:Remotion.Mixins.ComposedObject`1"/>.
            </typeparam>
            <remarks>
            <para>
            When a class inherits members provided by mixins, those additional members are only available by casting the class instance to the respective 
            interfaces introduced by the mixins. This can be cumbersome, so the concept of complete
            interfaces was added. A complete interface combines public members of the
            mixed class with members introduced by mixins. The target class members are added to the complete interface either by having the
            complete interface extend an interface also implemented by the target class, or by simply redeclaring the members of the target class on the
            complete interface. The mixin members are added to the complete interface by having the complete interface extend the interfaces 
            introduced by the mixins. For an example, see the documentation for the <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            <para>
            While complete interfaces provide easy access to the members added by mixins, they still require one cast (from the target class instance to
            the complete interface). To remove the need for this cast, classes implementing mixin-based composition can use the 
            <see cref="T:Remotion.Mixins.ComposedObject`1"/> base class. When a class derives from <see cref="T:Remotion.Mixins.ComposedObject`1"/>, 
            it defines a complete interface for itself and all
            the mixins it composes via the <see cref="T:Remotion.Mixins.UsesAttribute"/>. That complete interface is called the <typeparamref name="TComposedInterface"/>.
            </para>
            <para>
            The <see cref="T:Remotion.Mixins.ComposedObject`1"/> base class associates the <typeparamref name="TComposedInterface"/> with the derived class 
            and provides a <see cref="P:Remotion.Mixins.ComposedObject`1.This"/> property allowing access to all the members provided by the class and the composed mixins. Use the
            <see cref="P:Remotion.Mixins.ComposedObject`1.This"/> property as the full public API of the class.
            </para>
            <para>
            The base class checks that the derived class is always instantiated by the mixin engine, and it will throw an exception from its constructor 
            if this is not the case.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.IHasCompleteInterface`1">
            <summary>
            Defines <typeparamref name="TInterface"/> as a complete interface for the target class implementing the <see cref="T:Remotion.Mixins.IHasCompleteInterface`1"/> interface.
            </summary>
            <typeparam name="TInterface">The complete interface type.</typeparam>
            <remarks>
            <para>
            Complete interfaces are interfaces that comprise members implemented on a target class as well as members added by mixins to that target class.
            They can be used to access all members on a mixed instance without casting to mixin interfaces.
            </para>
            <para>
            For more information, see <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>. Implementing <see cref="T:Remotion.Mixins.IHasCompleteInterface`1"/> on a target 
            class has the same effect as marking the respective <typeparamref name="TInterface"/> with the <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            <para>
            <see cref="T:Remotion.Mixins.IHasCompleteInterface`1"/> is automatically taken into account when the declarative mixin configuration is analyzed.
            When building a mixin configuration using the fluent mixin building APIs (<see cref="M:Remotion.Mixins.MixinConfiguration.BuildNew()"/> and 
            similar), it is not automatically taken into account. Register the interface by hand using 
            <see cref="M:Remotion.Mixins.Context.FluentBuilders.ClassContextBuilder.AddCompleteInterface{TInterface}()"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ComposedObject`1.NewObject``1(Remotion.Reflection.ParamList)">
            <summary>
            Used to create instances of the class derived from <see cref="T:Remotion.Mixins.ComposedObject`1"/>.
            </summary>
            <typeparam name="TComposite">The type of the composite domain object to create. This must be a subclass of 
            <see cref="T:Remotion.Mixins.ComposedObject`1"/>.</typeparam>
            <param name="ctorArgs">The constructor arguments.</param>
            <returns>An instance of <typeparamref name="TComposite"/>, accessed via the <typeparamref name="TComposedInterface"/>.</returns>
        </member>
        <member name="M:Remotion.Mixins.ComposedObject`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.ComposedObject`1"/> class and checks that the instance was created by
            the mixin engine.
            </summary>
            <exception cref="T:System.InvalidOperationException">The instance was not created by the mixin engine. Use the <see cref="M:Remotion.Mixins.ComposedObject`1.NewObject``1(Remotion.Reflection.ParamList)"/>
            factory method, the <see cref="T:Remotion.Mixins.ObjectFactory"/>, or the <see cref="T:Remotion.Mixins.TypeFactory"/> to instantiate subclasses of 
            <see cref="T:Remotion.Mixins.ComposedObject`1"/>.</exception>
        </member>
        <member name="P:Remotion.Mixins.ComposedObject`1.This">
            <summary>
            Gets this <see cref="T:Remotion.Mixins.ComposedObject`1"/> instance via the <typeparamref name="TComposedInterface"/> interface type. 
            This enables callers to access the members of all composed mixins without explicit casts.
            </summary>
            <value>This instance, accessed via the <typeparamref name="TComposedInterface"/>.</value>
        </member>
        <member name="T:Remotion.Mixins.CopyCustomAttributesAttribute">
            <summary>
            When applied to a mixin, specifies a class whose custom attributes should be added to the mixin's target class. This is useful when a mixin
            should add certain attributes without itself exposing those attributes.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.ExtendsAttribute">
            <summary>
            Indicates that a mixin extends a specific class, providing some part of its functionality or public interface.
            </summary>
            <remarks>
            <para>
            This attribute is effective for the declarative mixin configuration, which is in effect by default when an application is started.
            </para>
            <para> 
            Although the attribute itself is not inherited, its semantics in mixin configuration are: If a base class is configured to be mixed with a
            mixin type M by means of the <see cref="T:Remotion.Mixins.ExtendsAttribute"/>, this configuration setting is inherited by each of its (direct and indirect) subclasses.
            The subclasses will therefore also be mixed with the same mixin type M unless a second mixin M2 derived from M is applied to the subclass, thus
            overriding the inherited configuration. If M is configured for both base class and subclass, the base class configuration is ignored.
            </para>
            <para>
            This attribute can be applied to the same mixin class multiple times if it extends multiple target classes. It should not however be used to
            apply the same mixin multiple times to the same target class.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.MixinRelationshipAttribute">
            <summary>
            Acts as a common base class for attributes used in declaratively specifying the mixin configuration by expressing the relationship between a
            mixin and its target class, eg. <see cref="T:Remotion.Mixins.ExtendsAttribute"/>, <see cref="T:Remotion.Mixins.UsesAttribute"/>, <see cref="T:Remotion.Mixins.MixAttribute"/>
            </summary>
        </member>
        <member name="P:Remotion.Mixins.MixinRelationshipAttribute.AdditionalDependencies">
            <summary>
            Gets or sets additional explicit base call dependencies for the applied mixin type. This can be used to establish an ordering when
            combining unrelated mixins on a class which override the same methods.
            </summary>
            <value>The additional dependencies of the mixin. The validity of the dependency types is not checked until the configuration is built.</value>
            <exception cref="T:System.ArgumentNullException">The <paramref name="value"/> argument is <see langword="null"/>.</exception>
        </member>
        <member name="P:Remotion.Mixins.MixinRelationshipAttribute.SuppressedMixins">
            <summary>
            Gets or sets the mixins suppressed by the applied mixin.
            </summary>
            <value>The mixins suppressed by the applied mixins.</value>
            <remarks>Use this attribute to actively remove a mixin from the attribute's target type. The list of suppressed mixins cannot contain 
            the applied mixin itself, but it can contain mixins which themselves suppress this mixin. Such circular suppressions result in both mixins
            being removed from the configuration.</remarks>
        </member>
        <member name="P:Remotion.Mixins.MixinRelationshipAttribute.IntroducedMemberVisibility">
            <summary>
            Gets or sets the default visibility of members introduced by the mixin to the target class. The default is <see cref="F:Remotion.Mixins.MemberVisibility.Private"/>.
            </summary>
            <value>The introduced member visibility.</value>
        </member>
        <member name="M:Remotion.Mixins.ExtendsAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.ExtendsAttribute"/> class.
            </summary>
            <param name="targetType">The target type extended by this mixin.</param>
        </member>
        <member name="P:Remotion.Mixins.ExtendsAttribute.TargetType">
            <summary>
            Gets the target type the mixin class applies to.
            </summary>
            <value>The target type the mixin class applies to.</value>
        </member>
        <member name="P:Remotion.Mixins.ExtendsAttribute.MixinTypeArguments">
            <summary>
            Gets or sets the generic type arguments to be used when applying a generic mixin to the given target type. This is useful when the
            <see cref="T:Remotion.Mixins.ExtendsAttribute"/> is to be applied to a generic mixin class, but the default generic type specialization algorithm of the
            mixin engine does not give the desired results.
            </summary>
            <value>The generic type arguments to close the generic mixin type with.</value>
            <remarks>If this attribute is applied to a non-generic mixin class or if the types supplied don't match the mixin's generic parameters,
            an exception is thrown when the mixin configuration is analyzed.</remarks>
        </member>
        <member name="T:Remotion.Mixins.GenerationPolicy">
            <summary>
            Defines how the <see cref="T:Remotion.Mixins.TypeFactory"/> and <see cref="T:Remotion.Mixins.ObjectFactory"/> behave when asked to generate a concrete type for a target
            type without any mixin configuration information.
            </summary>
        </member>
        <member name="F:Remotion.Mixins.GenerationPolicy.ForceGeneration">
            <summary>
            Specifies that <see cref="T:Remotion.Mixins.TypeFactory"/> and <see cref="T:Remotion.Mixins.ObjectFactory"/> should always generate concrete types, no matter whether
            mixin configuration information exists for the given target type or not.
            </summary>
        </member>
        <member name="F:Remotion.Mixins.GenerationPolicy.GenerateOnlyIfConfigured">
            <summary>
            Specifies that <see cref="T:Remotion.Mixins.TypeFactory"/> and <see cref="T:Remotion.Mixins.ObjectFactory"/> should only generate concrete types if
            mixin configuration information exists for the given target type.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.IgnoreForMixinConfigurationAttribute">
            <summary>
            Causes the mixin engine to ignore all mixin configuration attributes on the type this attribute is applied to when building the default
            mixin configuration.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.IgnoresClassAttribute">
            <summary>
            Defines that a mixin is not applied to a specific class, even when it is explicitly or implicitly configured for that class via
            the declarative configuration attributes <see cref="T:Remotion.Mixins.UsesAttribute"/>, <see cref="T:Remotion.Mixins.ExtendsAttribute"/>, and <see cref="T:Remotion.Mixins.MixAttribute"/>.
            </summary>
            <remarks>
            <para>
            Use this attribute to exclude a target class inherited from a mixin's base class. This attribute is not inherited, so the target class
            exclusion will only work for the exact mixin to which the attribute is applied.
            </para>
            <para>
            Note that when a mixin excludes a generic type definition (e.g. <c>C&lt;&gt;</c>), a corresponding closed generic type (<c>C&lt;int&gt;</c>) can
            still inherit the mixin from its base class. This is by design due to the rule that a closed generic type inherits mixins from both 
            its base class and its generic type definition.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.IgnoresClassAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.IgnoresClassAttribute"/> class, specifying the class to be ignored by this mixin.
            </summary>
            <param name="classToIgnore">The class to be ignored in declarative configuration. Subclasses of this class
            will not inherit the mixin either.</param>
        </member>
        <member name="P:Remotion.Mixins.IgnoresClassAttribute.ClassToIgnore">
            <summary>
            Gets the class to be ignored by this mixin.
            </summary>
            <value>The class to be ignored.</value>
        </member>
        <member name="T:Remotion.Mixins.IgnoresMixinAttribute">
            <summary>
            Defines that a specific mixin is not applied to a class, even when it is explicitly or implicitly configured for that class via
            the declarative configuration attributes <see cref="T:Remotion.Mixins.UsesAttribute"/>, <see cref="T:Remotion.Mixins.ExtendsAttribute"/>, and <see cref="T:Remotion.Mixins.MixAttribute"/>.
            </summary>
            <remarks>
            <para>
            Use this attribute to exclude a mixin that is configured to be applied to a base class. This attribute is not inherited, so the mixin
            exclusion will only work for the exact mixin to which the attribute is applied.
            </para>
            <para>
            Note that when a generic type definition (e.g. <c>C&lt;&gt;</c>) excludes a mixin, a corresponding closed generic class (<c>C&lt;int&gt;</c>) can
            still inherit the mixin from its base class. This is by design due to the rule that a closed generic type inherits mixins from both 
            its base class and its generic type definition.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.IgnoresMixinAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.IgnoresClassAttribute"/> class, specifying the mixin to be ignored by this class.
            </summary>
            <param name="mixinToIgnore">The mixin to be ignored in declarative configuration. Subclasses of this class will not inherit the mixin either.</param>
        </member>
        <member name="P:Remotion.Mixins.IgnoresMixinAttribute.MixinToIgnore">
            <summary>
            Gets the mixin to be ignored by this class.
            </summary>
            <value>The mixin to be ignored.</value>
        </member>
        <member name="T:Remotion.Mixins.IInitializableMixin">
            <summary>
            Denotes a mixin that can be initialized. This interface is used by the infrastructure and should not be applied by user code.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.IOverrideAttribute">
            <summary>
            Common interface for attributes specifying member overrides. This interface is used by the infrastructure and should not be applied by user code.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.MemberVisibility">
            <summary>
            Defines the visibility of members generated by the mixin infrastructure.
            </summary>
        </member>
        <member name="F:Remotion.Mixins.MemberVisibility.Private">
            <summary>
            The members are generated private.
            </summary>
        </member>
        <member name="F:Remotion.Mixins.MemberVisibility.Public">
            <summary>
            The members are generated public.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.MemberVisibilityAttribute">
            <summary>
            When applied to an interface member, defines the visibility of that member when it is introduced into a mixed type. This overrides the value
            specified via <see cref="P:Remotion.Mixins.MixinRelationshipAttribute.IntroducedMemberVisibility"/>.
            </summary>
        </member>
        <member name="M:Remotion.Mixins.MemberVisibilityAttribute.#ctor(Remotion.Mixins.MemberVisibility)">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.MemberVisibilityAttribute"/> class.
            </summary>
            <param name="visibility">The visibility to be used for the attributed member.</param>
        </member>
        <member name="P:Remotion.Mixins.MemberVisibilityAttribute.Visibility">
            <summary>
            Gets the visibility set to be used for the attributed member.
            </summary>
            <value>The visibility to be used.</value>
        </member>
        <member name="T:Remotion.Mixins.MixAttribute">
            <summary>
            Configures that a class and a mixin should be mixed together.
            </summary>
            <remarks>
            <para>
            This attribute is effective for the declarative mixin configuration, which is in effect by default when an application is started.
            </para>
            <para> 
            The <see cref="T:Remotion.Mixins.MixAttribute"/> is an alternative to <see cref="T:Remotion.Mixins.UsesAttribute"/> and <see cref="T:Remotion.Mixins.ExtendsAttribute"/> allowing assembly-level mixin
            configuration. Therefore, it is suitable for transparently putting mixins and classes together, with neither mixin nor target class explicitly
            referencing the other side of the relationship.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.MixAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.MixAttribute"/> class.
            </summary>
            <param name="targetType">The target type to be mixed.</param>
            <param name="mixinType">The mixin type to be mixed with the target type.</param>
        </member>
        <member name="P:Remotion.Mixins.MixAttribute.MixinKind">
            <summary>
            Gets or sets the kind of relationship between the mixin and its target class. For more information see <see cref="T:Remotion.Mixins.MixinKind"/>. If not
            explicitly specified, <see cref="F:Remotion.Mixins.MixinKind.Extending"/> is assumed.
            </summary>
            <value>The mixin kind.</value>
        </member>
        <member name="P:Remotion.Mixins.MixAttribute.TargetType">
            <summary>
            Gets the target type to be mixed.
            </summary>
            <value>The mixed type.</value>
        </member>
        <member name="P:Remotion.Mixins.MixAttribute.MixinType">
            <summary>
            Gets the mixin type mixed with the target class.
            </summary>
            <value>The mixin type.</value>
        </member>
        <member name="T:Remotion.Mixins.Mixin">
            <summary>
            Provides reflective access to the mixins integrated with a target class.
            </summary>
        </member>
        <member name="M:Remotion.Mixins.Mixin.Get``1(System.Object)">
            <summary>
            Gets the instance of the specified mixin type <typeparamref name="TMixin"/> that was mixed into the given <paramref name="mixinTarget"/>.
            </summary>
            <typeparam name="TMixin">The mixin type to get an instance of.</typeparam>
            <param name="mixinTarget">The mixin target to get the mixin instance from.</param>
            <returns>The instance of the specified mixin type that was mixed into the given mixin target, or <see langword="null"/> if the target does not
            include a mixin of that type.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="mixinTarget"/> parameter is <see langword="null"/>.</exception>
            <remarks>
            This method cannot be used with mixins that have been configured as open generic type definitions. Use the <see cref="M:Remotion.Mixins.Mixin.Get(System.Type,System.Object)">
            non-generic</see> variant instead.
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.Mixin.Get(System.Type,System.Object)">
            <summary>
            Gets the instance of the specified <paramref name="mixinType"/> that was mixed into the given <paramref name="mixinTarget"/>.
            </summary>
            <param name="mixinType">The mixin type to get an instance of.</param>
            <param name="mixinTarget">The mixin target to get the mixin instance from.</param>
            <returns>The instance of the specified mixin type that was mixed into the given mixin target, or <see langword="null"/> if the target does not
            include a mixin of that type.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="mixinType"/> or the <paramref name="mixinTarget"/> parameter is
            <see langword="null"/>.</exception>
            <remarks>
            This method can also be used with mixins that have been configured as open generic type definitions. Use the open generic type definition
            to retrieve them, but be prepared to get an instance of a specialized (closed) generic type back.
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.Mixin`2">
            <summary>
            Acts as a base class for mixins that require a reference to their target object (<see cref="P:Remotion.Mixins.Mixin`1.Target"/>) and a reference for calling 
            the base implementations of overridden methods (<see cref="P:Remotion.Mixins.Mixin`2.Next"/>).
            </summary>
            <typeparam name="TTarget">The minimum type required for calling methods on the target object (<see cref="P:Remotion.Mixins.Mixin`1.Target"/>). The
            mixin can only be applied to types that fulfill this type constraint either themselves or via other mixins.
            This type needn't actually be implemented by the target class. See Remarks section for details.
            </typeparam>
            <typeparam name="TNext">The minimum type required for making base calls (<see cref="P:Remotion.Mixins.Mixin`2.Next"/>) when overriding a method of the target class. 
            This type needn't actually be implemented by the target class. See Remarks section for details.</typeparam>
            <remarks>
            <para>
            Typically, this base class will be used whenever a mixin overrides a method of a target class and it needs to call the overridden base implementation.
            Derive from the <see cref="T:Remotion.Mixins.Mixin`1"/> class if you only need the target object reference but are not making any base calls, or use any
            base class if not even the target object reference is required.
            </para>
            <para>
            <typeparamref name="TTarget"/> is called the target-call dependency of the mixin, and can be assigned a class or interface (or a type parameter with 
            class or interface constraints). It defines the type of the <see cref="P:Remotion.Mixins.Mixin`1.Target"/> property, which is used to access the target
            instance of this mixin as well as members of other mixins applied to the same target instance. The mixin engine will ensure that 
            the target-call dependency is fulfilled either by the target class of the mixin, or by any mixin applied to the target class. 
            Accessing a member via the <see cref="P:Remotion.Mixins.Mixin`1.Target"/> property will actually access the corresponding member of the implementing target 
            class or mixin.
            </para>
            <para>
            <typeparamref name="TNext"/> is called the next-call dependency of the mixin and can be assigned an interface or
            the type <see cref="T:System.Object"/> (or a type parameter with interface or <see cref="T:System.Object"/> constraints). It defines the type
            of the <see cref="P:Remotion.Mixins.Mixin`2.Next"/> property, which is used when a mixin overrides a member of the target class and needs to call the next implementation 
            in the chain of overrides (or the base implementation on the target class, when there is no other mixin in the chain).
            The next-call dependencies of a mixin also define the order in which method overrides are executed when multiple mixins override the same target 
            method: when mixin A has a next-call dependency on an interface IB, its override will be executed before any mixin implementing the interface IB.
            </para>
            <para>If <typeparamref name="TTarget"/> or <typeparamref name="TNext"/> are interfaces, that dependency need not actually be implemented on the 
            target class as an interface is usually implemented. There are two additional possibilities:
            <list type="bullet">
            <item>
            The interface can be implemented on a mixin applied to the same target class.
            </item>
            <item>
            The members of the interface can be implemented on the target class with the same name and signature as defined by the interface (duck typing).
            </item>
            </list>
            The latter enables a mixin to define its dependencies even if the target class and any interfaces it implements are unknown.
            </para>
            <para>
            If a concrete mixin derived from this class is a generic type, it can be configured as a mixin in its open generic type definition form 
            (<c>typeof (C&lt;,&gt;)</c>). In such a case, the mixin engine will try to close it at the time of configuration analysis; for this, 
            binding information in the form of the <see cref="T:Remotion.Mixins.BindToTargetTypeAttribute"/>, <see cref="T:Remotion.Mixins.BindToConstraintsAttribute"/>, and 
            <see cref="T:Remotion.Mixins.BindToGenericTargetParameterAttribute"/> is used.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.Mixin`1">
            <summary>
            Acts as a base class for mixins that require a reference to their target object (<see cref="P:Remotion.Mixins.Mixin`1.Target"/>).
            </summary>
            <typeparam name="TTarget">The minimum type required for calling methods on the target object (<see cref="P:Remotion.Mixins.Mixin`1.Target"/>). The
            mixin can only be applied to types that fulfill this type constraint either themselves or via other mixins.
            This type needn't actually be implemented by the target class. See Remarks section for details.
            </typeparam>
            <remarks>
            <para>
            Typically, this base class will be used for those mixins which do require a reference to their target object, but which do not overrride
            any methods. 
            Derive from the <see cref="T:Remotion.Mixins.Mixin`2"/> class if you need to override target methods, or use any
            base class if not even the target object reference is required.
            </para>
            <para>
            <typeparamref name="TTarget"/> is called the target-call dependency of the mixin, and can be assigned a class or interface (or a type parameter with 
            class or interface constraints). It defines the type of the <see cref="P:Remotion.Mixins.Mixin`1.Target"/> property, which is used to access the target
            instance of this mixin as well as members of other mixins applied to the same target instance. The mixin engine will ensure that 
            the target-call dependency is fulfilled either by the target class of the mixin, or by any mixin applied to the target class. 
            Accessing a member via the <see cref="P:Remotion.Mixins.Mixin`1.Target"/> property will actually access the corresponding member of the implementing target 
            class or mixin.
            </para>
            <para>
            If <typeparamref name="TTarget"/> is an interface, that dependency need not actually be implemented on the 
            target class as an interface is usually implemented. There are two additional possibilities:
            <list type="bullet">
            <item>
            The interface can be implemented on a mixin applied to the same target class.
            </item>
            <item>
            The members of the interface can be implemented on the target class with the same name and signature as defined by the interface (duck typing).
            </item>
            </list>
            The latter enables a mixin to define its dependencies even if the target class and any interfaces it implements are unknown.
            </para>
            <para>
            If a concrete mixin derived from this class is a generic type, it can be configured as a mixin in its open generic type definition form 
            (<c>typeof (C&lt;&gt;)</c>). In such a case, the mixin engine will try to close it at the time of configuration analysis; for this, 
            binding information in the form of the <see cref="T:Remotion.Mixins.BindToTargetTypeAttribute"/>, <see cref="T:Remotion.Mixins.BindToConstraintsAttribute"/>, and 
            <see cref="T:Remotion.Mixins.BindToGenericTargetParameterAttribute"/> is used.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.Mixin`1.OnInitialized">
            <summary>
            Called when the mixin has been initialized and its properties can be safely accessed.
            </summary>
        </member>
        <member name="M:Remotion.Mixins.Mixin`1.OnDeserialized">
            <summary>
            Called when the mixin has been deserialized and its properties can be safely accessed.
            </summary>
        </member>
        <member name="P:Remotion.Mixins.Mixin`1.Target">
            <summary>
            Gets a reference to the concrete mixed object.
            </summary>
            <value>The target object reference.</value>
            <exception cref="T:System.InvalidOperationException">The mixin has not been initialized yet, probably because the property is accessed from the mixin's
            constructor.</exception>
            <remarks>
            This property must not be accessed from the mixin's constructor; if you need to initialize the mixin by accessing the <see cref="P:Remotion.Mixins.Mixin`1.Target"/>
            property, override the <see cref="M:Remotion.Mixins.Mixin`1.OnInitialized"/> method.
            <note type="warning">
            Be careful when calling members that this mixin overrides via the <see cref="P:Remotion.Mixins.Mixin`1.Target"/> property, this can easily throw a
            <see cref="T:System.StackOverflowException"/> because the <see cref="P:Remotion.Mixins.Mixin`1.Target"/> property includes all mixins defined on the target object. Use 
            <see cref="P:Remotion.Mixins.Mixin`2.Next"/> instead to call the base implementations of overridden members.
            </note>
            </remarks>
        </member>
        <member name="P:Remotion.Mixins.Mixin`2.Next">
            <summary>
            Provides a way to call the next or base implementation from member overrides.
            </summary>
            <value>The next implementation to be called.</value>
            <exception cref="T:System.InvalidOperationException">The mixin has not been initialized yet, probably because the property is accessed from the mixin's
            constructor.</exception>
            <remarks>
            <para>
            This property must not be accessed from the mixin's constructor; if you need to initialize the mixin by accessing the <see cref="P:Remotion.Mixins.Mixin`2.Next"/>
            property (which is unusual because the <see cref="P:Remotion.Mixins.Mixin`2.Next"/> property should only be used from member overrides), override the 
            <see cref="M:Remotion.Mixins.Mixin`1.OnInitialized"/> method.
            </para>
            <para>
            This property is only for calling the next implementation from overridden methods. It should not be used to access arbitrary methods of the 
            mixin's target object, use the <see cref="P:Remotion.Mixins.Mixin`1.Target"/> property instead. If the <see cref="P:Remotion.Mixins.Mixin`2.Next"/> property is used other than to 
            perform base calls from member overrides and more than one mixin is applied to the target object, unexpected behavior may arise because the 
            <see cref="P:Remotion.Mixins.Mixin`2.Next"/> property will represent the target object together with a subset (but not all) of its mixins.
            </para>
            <para>
            When a member is accessed via the <see cref="P:Remotion.Mixins.Mixin`2.Next"/> property, the member is actually called on either the next mixin in the override chain
            for the corresponding member, or on the target class if there are no more mixins in the chain. The order in which member overrides are
            chained is defined by mixin ordering, e.g. via the dependencies expressed via the <typeparamref name="TNext"/> parameter.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.MixinKind">
            <summary>
            Describes how a mixin influences its target class.
            </summary>
        </member>
        <member name="F:Remotion.Mixins.MixinKind.Extending">
            <summary>
            The mixin extends the target class from the outside, the target class might not know about being mixed. The mixin therefore has the
            possibility to override attributes (with <see cref="P:System.AttributeUsageAttribute.AllowMultiple"/> set to false) and interfaces declared
            or implemented by the target class.
            </summary>
        </member>
        <member name="F:Remotion.Mixins.MixinKind.Used">
            <summary>
            The mixin is explicitly used by the target class. The mixin therefore behaves more like a base class, eg. attributes (with 
            <see cref="P:System.AttributeUsageAttribute.AllowMultiple"/> set to false) and interfaces introduced by the mixin can be overridden by the 
            target class.
            </summary>
        </member>
        <member name="T:Remotion.Mixins.NonIntroducedAttribute">
            <summary>
            When applied to a mixin, specifies that this mixin does not introduce a specific interface or attribute to the target class.
            </summary>
            <remarks>Use this attribute if a mixin should implement an interface or declare an attribute "just for itself" and the interface should not be
            forwarded to the target class.</remarks>
        </member>
        <member name="T:Remotion.Mixins.ObjectFactory">
            <summary>
            Provides support for instantiating type which are combined with mixins.
            </summary>
            <remarks>
            <para>
            When a target class ist combined with mixins, the target class cannot be instantiated by an ordinary constructor call. 
            Instead, a mixed type has to be created first, and this type is then instantiated.
            The <see cref="T:Remotion.Mixins.ObjectFactory"/> class provides a simple API to creating and instantiating mixed types. (To create a mixed type
            without instantiating it, use the <see cref="T:Remotion.Mixins.TypeFactory"/> class.)
            </para>
            <para>
            The <see cref="T:Remotion.Mixins.ObjectFactory"/> class uses the mixin configuration active on the current thread. Use the 
            <c>MixinConfiguration</c> class if the configuration needs to be adapted.
            </para>
            </remarks>
            <threadsafety static="true" instance="true"/>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create``1">
            <summary>
            Creates a mixed instance of the given type <typeparamref name="T"/> with a public default constructor.
            </summary>
            <typeparam name="T">The target type a mixed instance of which should be created.</typeparam>
            <returns>A mixed instance of a type derived from <typeparamref name="T"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The base type <typeparamref name="T"/> is an interface and it cannot be determined which class to instantiate.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/> with
            <see cref="F:Remotion.Mixins.GenerationPolicy.GenerateOnlyIfConfigured"/>. This means that mixed types are only created for
            instances which do have an active mixin configuration. All other types passed to this method are directly instantiated, without code
            generation.
            </para>
            <para>
            The <see cref="M:Remotion.Mixins.ObjectFactory.Create(System.Type,Remotion.Reflection.ParamList,System.Object[])"/> method supports the creation of instances from their complete interfaces:
            <typeparamref name="T"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create``1(Remotion.Reflection.ParamList,System.Object[])">
            <summary>
            Creates a mixed instance of the given type <typeparamref name="T"/> with a public constructor.
            </summary>
            <typeparam name="T">The target type a mixed instance of which should be created.</typeparam>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <typeparamref name="T"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <typeparamref name="T"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The base type <typeparamref name="T"/> is an interface and it cannot be determined which class to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/> with
            <see cref="F:Remotion.Mixins.GenerationPolicy.GenerateOnlyIfConfigured"/>. This means that mixed types are only created for
            instances which do have an active mixin configuration. All other types passed to this method are directly instantiated, without code
            generation.
            </para>
            <para>
            The <see cref="M:Remotion.Mixins.ObjectFactory.Create(System.Type,Remotion.Reflection.ParamList,System.Object[])"/> method supports the creation of instances from their complete interfaces:
            <typeparamref name="T"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create``1(Remotion.Reflection.ParamList,Remotion.Mixins.GenerationPolicy,System.Object[])">
            <summary>
            Creates a mixed instance of the given base type <typeparamref name="T"/> with a public constructor.
            </summary>
            <typeparam name="T">The target type a mixed instance of which should be created.</typeparam>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="generationPolicy">Indicates whether a derived class should be generated even for types that do not have an active mixin configuration.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <typeparamref name="T"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <typeparamref name="T"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The base type <typeparamref name="T"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/>. This means that mixed types might
            be created even for instances which do not have an active mixin configuration, as specified with the <paramref name="generationPolicy"/>
            parameter. In that case, all objects created via this method can be treated in the same way, but it might be inefficient to create arbitrary
            non-mixed objects with this policy.
            </para>
            <para>
            This method supports the creation of instances from their complete interfaces: <typeparamref name="T"/> can be an
            interface registered in the current mixin configuration. See also <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create(System.Type)">
            <summary>
            Creates a mixed instance of the given <paramref name="targetOrConcreteType"/> with a public default constructor.
            </summary>
            <param name="targetOrConcreteType">The target type a mixed instance of which should be created or a concrete mixed type.</param>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="targetOrConcreteType"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The <paramref name="targetOrConcreteType"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/> with
            <see cref="F:Remotion.Mixins.GenerationPolicy.GenerateOnlyIfConfigured"/>. This means that mixed types are only created for
            instances which do have an active mixin configuration. All other types passed to this method are directly instantiated, without code
            generation.
            </para>
            <para>
            This method supports the creation of instances from their complete interfaces:
            <paramref name="targetOrConcreteType"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            <para>
            If <paramref name="targetOrConcreteType"/> is already a generated type, this method will not subclass it again.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create(System.Type,Remotion.Reflection.ParamList,System.Object[])">
            <summary>
            Creates a mixed instance of the given <paramref name="targetOrConcreteType"/> with a public constructor.
            </summary>
            <param name="targetOrConcreteType">The target type a mixed instance of which should be created or a concrete mixed type.</param>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <paramref name="targetOrConcreteType"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <paramref name="targetOrConcreteType"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="targetOrConcreteType"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The <paramref name="targetOrConcreteType"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/> with
            <see cref="F:Remotion.Mixins.GenerationPolicy.GenerateOnlyIfConfigured"/>. This means that mixed types are only created for
            instances which do have an active mixin configuration. All other types passed to this method are directly instantiated, without code
            generation.
            </para>
            <para>
            This method supports the creation of instances from their complete interfaces:
            <paramref name="targetOrConcreteType"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            <para>
            If <paramref name="targetOrConcreteType"/> is already a generated type, this method will not subclass it again.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create(System.Type,Remotion.Reflection.ParamList,Remotion.Mixins.GenerationPolicy,System.Object[])">
            <summary>
            Creates a mixed instance of the given <paramref name="targetOrConcreteType"/> with a public constructor.
            </summary>
            <param name="targetOrConcreteType">The target type a mixed instance of which should be created or a concrete mixed type.</param>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="generationPolicy">Indicates whether a derived class should be generated even for types that do not have an active mixin configuration.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <paramref name="targetOrConcreteType"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <paramref name="targetOrConcreteType"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="targetOrConcreteType"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The <paramref name="targetOrConcreteType"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/>. This means that mixed types might
            be created even for instances which do not have an active mixin configuration, as specified with the <paramref name="generationPolicy"/>
            parameter. In that case, all objects created via this method can be treated in the same way, but it might be inefficient to create arbitrary
            non-mixed objects with this policy.
            </para>
            <para>
            This method supports the creation of instances from their complete
            interfaces: <paramref name="targetOrConcreteType"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            <para>
            If <paramref name="targetOrConcreteType"/> is already a generated type, this method will only subclass it again when
            <see cref="F:Remotion.Mixins.GenerationPolicy.ForceGeneration"/> is specified.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create``1(System.Boolean,Remotion.Reflection.ParamList,System.Object[])">
            <summary>
            Creates a mixed instance of the given base type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The target type a mixed instance of which should be created.</typeparam>
            <param name="allowNonPublicConstructors">If true, the factory will also construct objects without a public constructor. If false, an exception is thrown
            unless a public constructor is available.</param>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <typeparamref name="T"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <typeparamref name="T"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The base type <typeparamref name="T"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/> with
            <see cref="F:Remotion.Mixins.GenerationPolicy.GenerateOnlyIfConfigured"/>. This means that mixed types are only created for
            instances which do have an active mixin configuration. All other types passed to this method are directly instantiated, without code
            generation.
            </para>
            <para>
            This method supports the creation of instances from their complete interfaces:
            <typeparamref name="T"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create``1(System.Boolean,Remotion.Reflection.ParamList,Remotion.Mixins.GenerationPolicy,System.Object[])">
            <summary>
            Creates a mixed instance of the given base type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The target type a mixed instance of which should be created.</typeparam>
            <param name="allowNonPublicConstructors">If true, the factory will also construct objects without a public constructor. If false, an exception is thrown
            unless a public constructor is available.</param>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="generationPolicy">Indicates whether a derived class should be generated even for types that do not have an active mixin configuration.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <typeparamref name="T"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <typeparamref name="T"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The base type <typeparamref name="T"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/>. This means that mixed types might
            be created even for instances which do not have an active mixin configuration, as specified with the <paramref name="generationPolicy"/>
            parameter. In that case, all objects created via this method can be treated in the same way, but it might be inefficient to create arbitrary
            non-mixed objects with this policy.
            </para>
            <para>
            This method supports the creation of instances from their complete interfaces: <typeparamref name="T"/> can be an
            interface registered in the current mixin configuration. See also <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create(System.Boolean,System.Type,Remotion.Reflection.ParamList,System.Object[])">
            <summary>
            Creates a mixed instance of the given <paramref name="targetOrConcreteType"/>.
            </summary>
            <param name="allowNonPublicConstructors">If true, the factory will also construct objects without a public constructor. If false, an exception is thrown
            unless a public constructor is available.</param>
            <param name="targetOrConcreteType">The target type a mixed instance of which should be created or a concrete mixed type.</param>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <paramref name="targetOrConcreteType"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <paramref name="targetOrConcreteType"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="targetOrConcreteType"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The <paramref name="targetOrConcreteType"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/> with
            <see cref="F:Remotion.Mixins.GenerationPolicy.GenerateOnlyIfConfigured"/>. This means that mixed types are only created for
            instances which do have an active mixin configuration. All other types passed to this method are directly instantiated, without code
            generation.
            </para>
            <para>
            This method supports the creation of instances from their complete interfaces:
            <paramref name="targetOrConcreteType"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            <para>
            If <paramref name="targetOrConcreteType"/> is already a generated type, this method will not subclass it again.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.ObjectFactory.Create(System.Boolean,System.Type,Remotion.Reflection.ParamList,Remotion.Mixins.GenerationPolicy,System.Object[])">
            <summary>
            Creates a mixed instance of the given <paramref name="targetOrConcreteType"/>.
            </summary>
            <param name="allowNonPublicConstructors">If true, the factory will also construct objects without a public constructor. If false, an exception is thrown
            unless a public constructor is available.</param>
            <param name="targetOrConcreteType">The target type a mixed instance of which should be created or a concrete mixed type.</param>
            <param name="constructorParameters">A <see cref="T:Remotion.Reflection.ParamList"/> object holding the parameters to be passed to the constructor.</param>
            <param name="generationPolicy">Indicates whether a derived class should be generated even for types that do not have an active mixin configuration.</param>
            <param name="preparedMixins">The pre-instantiated mixin instances to integrate into the mixed instance. You can specify all, none, or a subset
            of the mixins currently configured with <paramref name="targetOrConcreteType"/>. Those mixins for which no
            prepared instances are given will be automatically created when the mixed object is constructed.</param>
            <returns>A mixed instance of a type derived from <paramref name="targetOrConcreteType"/>.</returns>
            <exception cref="T:Remotion.Mixins.Validation.ValidationException">
            <para>
            The current mixin configuration for the target type violates at least one validation rule, which makes it impossible to crate
            a mixed type.
            </para>
            </exception>
            <exception cref="T:System.Exception">
            <para>
            The current mixin configuration for the target type contains severe configuration problems that make generation of a 
            target class definition object impossible.
            </para>
            <para>- or -</para>
            <para>
            The constructor of the mixed object threw an exception.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="targetOrConcreteType"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">
            <para>
            The <paramref name="targetOrConcreteType"/> is an interface and it cannot be determined which class
            to instantiate.
            </para>
            <para>
            -or-
            </para>
            <para>
            The <paramref name="preparedMixins"/> parameter contains at least one mixin instance which is not
            defined as a mixin for the target type in the current thread's mixin configuration.
            </para>
            </exception>
            <remarks>
            <para>
            This method internally uses <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/>. This means that mixed types might
            be created even for instances which do not have an active mixin configuration, as specified with the <paramref name="generationPolicy"/>
            parameter. In that case, all objects created via this method can be treated in the same way, but it might be inefficient to create arbitrary
            non-mixed objects with this policy.
            </para>
            <para>
            This method supports the creation of instances from their complete
            interfaces: <paramref name="targetOrConcreteType"/> can be an interface registered in the current mixin configuration. See also
            <see cref="T:Remotion.Mixins.CompleteInterfaceAttribute"/>.
            </para>
            <para>
            If <paramref name="targetOrConcreteType"/> is already a generated type, this method will only subclass it again when
            <see cref="F:Remotion.Mixins.GenerationPolicy.ForceGeneration"/> is specified.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.OverrideMixinAttribute">
            <summary>
            Indicates that a target class member overrides a virtual or abstract member of one of the mixins combined with the class.
            </summary>
            <remarks>
            <para>
            An overriding member and its base member must both be public or protected, and they must have the same name and signature. If an overriding
            member would apply to multiple mixin members, this is regarded as a configuration error, unless the mixin type is explicitly specified in
            this attribute's constructor.
            </para>
            <para>
            This attribute is inherited (i.e. if the overriding member is replaced in a subclass, the subclass' member is now the overriding member) and
            can only be applied once per member.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.OverrideMixinAttribute.#ctor">
            <summary>
            Indicates that this member overrides a virtual or abstract member of one of the mixins combined with the class. The overridden member
            has the same name and signature as this member. If more than one mixin defines such a member, an exception is thrown.
            </summary>
        </member>
        <member name="M:Remotion.Mixins.OverrideMixinAttribute.#ctor(System.Type)">
            <summary>
            Indicates that this member overrides a virtual or abstract member of the given mixin type. The overridden member
            has the same name and signature as this member. If the given mixin type is not part of the current configuration, an exception is thrown.
            </summary>
            <param name="mixinType">The type (or base type or interface) of the mixin whose member to override. For generic mixins, you can specify the
            open type (with unbound generic parameters) even if the configuration contains a closed type (with bound parameters).</param>
        </member>
        <member name="T:Remotion.Mixins.OverrideTargetAttribute">
            <summary>
            Indicates that a mixin member overrides a virtual member of the mixin's target class.
            </summary>
            <remarks>
            <para>
            An overriding member and its base member must both be public or protected, and they must have the same name and signature.
            </para>
            <para>
            This attribute is inherited (i.e. if the overriding member is replaced in a subclass, the subclass' member is now the overriding member) and
            can only be applied once per member.
            </para>
            </remarks>
        </member>
        <member name="T:Remotion.Mixins.TypeFactory">
            <summary>
            Provides support for combining mixins and target classes into concrete, "mixed", instantiable types.
            </summary>
            <remarks>
            <para>
            When a target class should be combined with mixins, the target class (and sometimes also the mixin types) cannot be instantiated as
            is. Instead, a concrete type has to be created which incorporates the necessary delegation code. While the type generation is actually performed
            by another class, the <see cref="T:Remotion.Mixins.TypeFactory"/> provides the public API to be used when retrieving a generated type.
            </para>
            <para>
            The <see cref="T:Remotion.Mixins.TypeFactory"/> should only be used if <see cref="T:System.Type"/> objects are required. If the combined type should be instantiated,
            the <see cref="T:Remotion.Mixins.ObjectFactory"/> class should be used instead.
            </para>
            <para>
            The <see cref="T:Remotion.Mixins.TypeFactory"/> class uses the mixin configuration active for the thread on which it is called.
            </para>
            </remarks>
            <threadsafety static="true" instance="true"/>
        </member>
        <member name="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type)">
            <summary>
            Retrieves a concrete, instantiable, mixed type for the given <paramref name="targetOrConcreteType"/>, or <paramref name="targetOrConcreteType"/> itself if no
            mixin configuration exists for the type on the current thread.
            </summary>
            <param name="targetOrConcreteType">Base type for which a mixed type should be retrieved or a concrete mixed type.</param>
            <returns>A concrete, instantiable, mixed type for the given <paramref name="targetOrConcreteType"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="targetOrConcreteType"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.Exception"><para>The current mixin configuration for the <paramref name="targetOrConcreteType"/> contains severe configuration problems 
            that make generation of a target class definition object impossible.</para><para>- or -</para><para>The current mixin configuration for 
            the <paramref name="targetOrConcreteType"/> violates at least one validation rule, which makes code generation impossible.</para> </exception>
            <remarks>
            <para>
            The type returned by this method is guaranteed to be derived from <paramref name="targetOrConcreteType"/>, but will usually not be the same as
            <paramref name="targetOrConcreteType"/>. It manages integration of the mixins with the given <paramref name="targetOrConcreteType"/>.
            </para>
            <para>
            Note that the factory will not create derived types for types not currently having a mixin configuration. This means that types returned
            by the factory can <b>not</b> always be treated as derived types. See <see cref="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)"/> on how to
            force generation of a derived type.
            </para>
            <para>
            The returned type provides the same constructors as <paramref name="targetOrConcreteType"/> does and can thus be instantiated, e.g. via
            <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>. When this happens, all the mixins associated with the generated type are also
            instantiated and configured to be used with the target instance. If you need to supply pre-created mixin instances for an object, use
            a <em>MixedObjectInstantiationScope</em>. See <see cref="T:Remotion.Mixins.ObjectFactory"/> for a simpler way to immediately create instances of mixed types.
            </para>
            <para>
            If <paramref name="targetOrConcreteType"/> is already a generated type, this method will not subclass it again.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.TypeFactory.GetConcreteType(System.Type,Remotion.Mixins.GenerationPolicy)">
            <summary>
            Retrieves a concrete, instantiable, mixed type for the given <paramref name="targetOrConcreteType"/>.
            </summary>
            <param name="targetOrConcreteType">Base type for which a mixed type should be retrieved or a concrete mixed type.</param>
            <param name="generationPolicy">Defines whether to force generation of a type even if no mixin configuration is currently available
            for the given type.</param>
            <returns>A concrete, instantiable, mixed type for the given <paramref name="targetOrConcreteType"/>, or the type itself; depending on the
            <paramref name="generationPolicy"/> and the active configuration.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="targetOrConcreteType"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.Exception"><para>The current mixin configuration for the <paramref name="targetOrConcreteType"/> contains severe configuration problems 
            that make generation of a target class definition object impossible.</para><para>- or -</para><para>The current mixin configuration for 
            the <paramref name="targetOrConcreteType"/> violates at least one validation rule, which makes code generation impossible.</para> </exception>
            <remarks>
            <para>
            The type returned by this method is guaranteed to be derived from <paramref name="targetOrConcreteType"/>, but will usually not be the same as
            <paramref name="targetOrConcreteType"/>. It manages integration of the mixins with the given <paramref name="targetOrConcreteType"/>.
            </para>
            <para>
            Note that the factory can create empty mixin configurations for types not currently having a mixin configuration, depending on the
            <paramref name="generationPolicy"/>. With <see cref="F:Remotion.Mixins.GenerationPolicy.ForceGeneration"/>, types returned by the factory can always be treated
            as derived types.
            </para>
            <para>
            The returned type provides the same constructors as <paramref name="targetOrConcreteType"/> does and can thus be instantiated, e.g. via
            <see cref="M:System.Activator.CreateInstance(System.Type,System.Object[])"/>. When this happens, all the mixins associated with the generated type are also
            instantiated and configured to be used with the target instance. If you need to supply pre-created mixin instances for an object, use
            a <em>MixedObjectInstantiationScope</em>. See <see cref="T:Remotion.Mixins.ObjectFactory"/> for a simpler way to immediately create instances of mixed types.
            </para>
            <para>
            If <paramref name="targetOrConcreteType"/> is already a generated type, this method will only subclass it again when
            <see cref="F:Remotion.Mixins.GenerationPolicy.ForceGeneration"/> is specified.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.TypeFactory.InitializeUnconstructedInstance(System.Object)">
            <summary>
            Initializes a mixin target instance which was created without its constructor having been called.
            </summary>
            <param name="mixinTarget">The mixin target to initialize.</param>
            <exception cref="T:System.ArgumentNullException">The mixin target is <see langword="null"/>.</exception>
            <remarks>This method is useful when a mixin target instance is created via <see cref="M:System.Runtime.Serialization.FormatterServices.GetSafeUninitializedObject(System.Type)"/>.</remarks>
        </member>
        <member name="T:Remotion.Mixins.UsesAttribute">
            <summary>
            Indicates that a class integrates a mixin to implement some part of its functionality or public interface.
            </summary>
            <remarks>
            <para>
            This attribute is effective for the declarative mixin configuration, which is in effect by default when an application is started.
            </para>
            <para> 
            Although the attribute itself is not inherited, its semantics in mixin configuration are: If a base class is configured to be mixed with a
            mixin type M by means of the <see cref="T:Remotion.Mixins.UsesAttribute"/>, this configuration setting is inherited by each of its (direct and indirect) subclasses.
            The subclasses will therefore also be mixed with the same mixin type M unless a second mixin M2 derived from M is applied to the subclass, thus
            overriding the inherited configuration. If M is configured for both base class and subclass, the base class configuration is ignored.
            </para>
            <para>
            This attribute can be applied to the same target class multiple times if a class depends on multiple mixins, but it should not be used to
            apply the same mixin multiple times to the same target class.
            </para>
            </remarks>
        </member>
        <member name="M:Remotion.Mixins.UsesAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Remotion.Mixins.UsesAttribute"/> class.
            </summary>
            <param name="mixinType">The mixin type the class depends on.</param>
        </member>
        <member name="P:Remotion.Mixins.UsesAttribute.MixinType">
            <summary>
            Gets the mixin type the class depends on.
            </summary>
            <value>The mixin type the class depends on.</value>
        </member>
        <member name="T:Remotion.PermanentGuidAttribute">
            <summary>
              Supplies an identifier that should remain constant even accross refactorings. Can be applied to reference types, properties and fields.
            </summary>
        </member>
        <member name="M:Remotion.PermanentGuidAttribute.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Remotion.PermanentGuidAttribute"/> class.
            </summary>
            <param name="value"> The <see cref="T:System.String"/> representation of a <see cref="T:System.Guid"/>. </param>
        </member>
        <member name="P:Remotion.PermanentGuidAttribute.Value">
            <summary>
              Gets the <see cref="T:System.Guid"/> supplied during initialization.
            </summary>
        </member>
        <member name="T:Remotion.Reflection.IMemberInformation">
            <summary>
            Provides  information about the attributes of a member and provides access to member metadata.
            <seealso cref="T:Remotion.Reflection.IPropertyInformation"/>
            <seealso cref="T:Remotion.Reflection.IMethodInformation"/>
            </summary>
        </member>
        <member name="M:Remotion.Reflection.IMemberInformation.GetOriginalDeclaringType">
            <summary>
            Gets the type the member was originally declared on.
            </summary>
            <returns>The type the member was originally declared on.</returns>
            <remarks>If the member represented by this instance overrides a member from a base type, this method will return the base type.</remarks>
        </member>
        <member name="M:Remotion.Reflection.IMemberInformation.GetCustomAttribute``1(System.Boolean)">
            <summary>
            Gets the one custom attribute of type <typeparamref name="T"/> declared on this member, or null if no such attribute exists.
            </summary>
            <typeparam name="T">The type of attribute to retrieve.</typeparam>
            <param name="inherited">If set to true, the inheritance hierarchy is searched for the attribute. Otherwise, only the <see cref="P:Remotion.Reflection.IMemberInformation.DeclaringType"/>
            is checked.</param>
            <exception cref="T:System.Reflection.AmbiguousMatchException">More than one instance of the given attribute type <typeparamref name="T"/> is declared on this
            member.</exception>
            <returns>An instance of type <typeparamref name="T"/>, or <see langword="null"/> if no attribute of that type is declared on this member.</returns>
        </member>
        <member name="M:Remotion.Reflection.IMemberInformation.GetCustomAttributes``1(System.Boolean)">
            <summary>
            Gets the custom attributes of type <typeparamref name="T"/> declared on this member, or null if no such attribute exists.
            </summary>
            <typeparam name="T">The type of the attributes to retrieve.</typeparam>
            <param name="inherited">If set to true, the inheritance hierarchy is searched for the attributes. Otherwise, only the <see cref="P:Remotion.Reflection.IMemberInformation.DeclaringType"/>
            is checked.</param>
            <returns>An array of the attributes of type <typeparamref name="T"/> declared on this member, or an empty array if no attribute of
            that type is declared on this member.</returns>
        </member>
        <member name="M:Remotion.Reflection.IMemberInformation.IsDefined``1(System.Boolean)">
            <summary>
            Determines whether a custom attribute of the specified type <typeparamref name="T"/> is defined on the member.
            </summary>
            <typeparam name="T">The type of attribute to search for.</typeparam>
            <param name="inherited">If set to true, the inheritance hierarchy is searched for the attribute. Otherwise, only the type
            is checked.</param>
            <returns>
            True if a custom attribute of the specified type is defined on the member; otherwise, false.
            </returns>
        </member>
        <member name="M:Remotion.Reflection.IMemberInformation.FindInterfaceImplementation(System.Type)">
            <summary>
            Finds the implementation <see cref="T:Remotion.Reflection.IMemberInformation"/> corresponding to this <see cref="T:Remotion.Reflection.IMemberInformation"/> on the given 
            <see cref="T:System.Type"/>. This <see cref="T:Remotion.Reflection.IMemberInformation"/> object must denote an interface member.
            </summary>
            <param name="implementationType">The type to search for an implementation of this <see cref="T:Remotion.Reflection.IMemberInformation"/> on.</param>
            <returns>An instance of <see cref="T:Remotion.Reflection.IMemberInformation"/> describing the member implementing this interface 
            <see cref="T:Remotion.Reflection.IMemberInformation"/> on <paramref name="implementationType"/>, or <see langword="null"/> if the 
            <paramref name="implementationType"/> does not implement the interface.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="implementationType"/> is itself an interface.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:Remotion.Reflection.IMemberInformation"/> does not describe an interface member.</exception>
        </member>
        <member name="M:Remotion.Reflection.IMemberInformation.FindInterfaceDeclaration">
            <summary>
            Finds the interface declaration for this <see cref="T:Remotion.Reflection.IMemberInformation"/>, returning <see langword="null"/> if this 
            <see cref="T:Remotion.Reflection.IMemberInformation"/> is not an implementation of an interface member.
            </summary>
            <returns>An <see cref="T:Remotion.Reflection.IMemberInformation"/> for the interface member this <see cref="T:Remotion.Reflection.IMemberInformation"/> implements, or 
            <see langword="null"/> if this <see cref="T:Remotion.Reflection.IMemberInformation"/> is not an implementation of an interface member.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:Remotion.Reflection.IMemberInformation"/> is itself an interface member, so it cannot have an 
            interface declaration.</exception>
        </member>
        <member name="P:Remotion.Reflection.IMemberInformation.Name">
            <summary>
            Gets the simple name of the member identifying it within its declaring type.
            </summary>
            <value>The simple property name.</value>
        </member>
        <member name="P:Remotion.Reflection.IMemberInformation.DeclaringType">
            <summary>
            Gets the type declaring the member.
            </summary>
            <value>The declaring type of the property.</value>
        </member>
        <member name="T:Remotion.Reflection.IMethodInformation">
            <summary>
            Provides information about a method and offers a way to invoke the method.
            </summary>
        </member>
        <member name="M:Remotion.Reflection.IMethodInformation.Invoke(System.Object,System.Object[])">
            <summary>
            Invokes the method on the given instance using the given parameters.
            </summary>
            <param name="instance">The instance on which to invoke the method. If the method is static this argument is ignored.</param>
            <param name="parameters">An argument list for the invoked method.</param>
            <returns>An object containing the return value of the invoked method.</returns>
        </member>
        <member name="M:Remotion.Reflection.IMethodInformation.FindInterfaceImplementation(System.Type)">
            <summary>
            Finds the implementation <see cref="T:Remotion.Reflection.IMethodInformation"/> corresponding to this <see cref="T:Remotion.Reflection.IMethodInformation"/> on the given 
            <see cref="T:System.Type"/>. This <see cref="T:Remotion.Reflection.IMethodInformation"/> object must denote an interface method.
            </summary>
            <param name="implementationType">The type to search for an implementation of this <see cref="T:Remotion.Reflection.IMethodInformation"/> on.</param>
            <returns>An instance of <see cref="T:Remotion.Reflection.IMethodInformation"/> describing the method implementing this interface 
            <see cref="T:Remotion.Reflection.IMethodInformation"/> on <paramref name="implementationType"/>, or <see langword="null"/> if the 
            <paramref name="implementationType"/> does not implement the interface.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="implementationType"/> is itself an interface.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:Remotion.Reflection.IMethodInformation"/> does not describe an interface method.</exception>
        </member>
        <member name="M:Remotion.Reflection.IMethodInformation.FindDeclaringProperty">
            <summary>
            Finds the property declaration corresponding to this <see cref="T:Remotion.Reflection.IMethodInformation"/> on the given <see cref="T:System.Type"/> and it's base types.
            </summary>
            <returns>Returns the <see cref="T:Remotion.Reflection.IPropertyInformation"/> of the declared property, or <see langword="null"/> if no corresponding property was 
            found.</returns>
        </member>
        <member name="M:Remotion.Reflection.IMethodInformation.FindInterfaceDeclaration">
            <summary>
            Finds the interface declaration for this <see cref="T:Remotion.Reflection.IMethodInformation"/>, returning <see langword="null"/> if this 
            <see cref="T:Remotion.Reflection.IMethodInformation"/> is not an implementation of an interface member.
            </summary>
            <returns>An <see cref="T:Remotion.Reflection.IMethodInformation"/> for the interface member this <see cref="T:Remotion.Reflection.IMethodInformation"/> implements, or 
            <see langword="null"/> if this <see cref="T:Remotion.Reflection.IMethodInformation"/> is not an implementation of an interface member.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:Remotion.Reflection.IMethodInformation"/> is itself an interface member, so it cannot have an 
            interface declaration.</exception>
        </member>
        <member name="M:Remotion.Reflection.IMethodInformation.GetFastInvoker``1">
            <summary>
            Returns a delegate invoking the method described by this <see cref="T:Remotion.Reflection.IMethodInformation"/>.
            </summary>
            <typeparam name="T">
            The delegate type. The number of parameters and the fact whether or not a return type is present must match the signature of the method. The
            types need not match exactly; the values will be converted at run-time. 
            </typeparam>
            <returns>A delegate of type <typeparamref name="T"/> invoking the method described by this <see cref="T:Remotion.Reflection.IMethodInformation"/>.</returns>
        </member>
        <member name="M:Remotion.Reflection.IMethodInformation.GetFastInvoker(System.Type)">
            <summary>
            Returns a delegate invoking the method described by this <see cref="T:Remotion.Reflection.IMethodInformation"/>.
            </summary>
            <param name="delegateType">
            The delegate type. The number of parameters and the fact whether or not a return type is present must match the signature of the method. The
            types need not match exactly; the values will be converted at run-time. 
            </param>
            <returns>A delegate of type <paremref name="delegateType"/> invoking the method described by this <see cref="T:Remotion.Reflection.IMethodInformation"/>.</returns>
        </member>
        <member name="P:Remotion.Reflection.IMethodInformation.ReturnType">
            <summary>
            Gets the return type of the method.
            </summary>
            <value>The return type of the method.</value>
        </member>
        <member name="T:Remotion.Reflection.IPropertyInformation">
            <summary>
            Provides information about a property and offers a way to get or set the property's value.
            </summary>
        </member>
        <member name="M:Remotion.Reflection.IPropertyInformation.GetValue(System.Object,System.Object[])">
            <summary>
            Gets the value of the property for the given instance.
            </summary>
            <param name="instance">The instance to retrieve the value for, or <see langword="null"/> for a static property.</param>
            <param name="indexParameters">The index parameters to be used for property value retrieval.</param>
            <returns>The property's value for the given instance.</returns>
            <exception cref="T:System.ArgumentException">
            <para>The type of the elements of the <paramref name="indexParameters"/> array does not match the index argument types expected by the
            property.</para>
            <para>-or-</para>
            <para>The get accessor cannot be found.</para>
            </exception>
            <exception cref="T:System.Reflection.TargetException">The <paramref name="instance"/> parameter is <see langword="null"/> although the property is not a static
            property or it does not match the property's declaring type.</exception>
            <exception cref="T:System.Reflection.TargetParameterCountException">The number of items in the <paramref name="indexParameters"/> array does not match the number
            of index parameters expected by the property.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">The property's get method throw an exception, see the <see cref="P:System.Exception.InnerException"/>
            property.</exception>
            <exception cref="T:System.MethodAccessException">The accessor was private or protected and could not be executed.</exception>
        </member>
        <member name="M:Remotion.Reflection.IPropertyInformation.SetValue(System.Object,System.Object,System.Object[])">
            <summary>
            Sets the value of the property for the given instance.
            </summary>
            <param name="instance">The instance to set the value for, or <see langword="null"/> for a static property.</param>
            <param name="value">The property's value for the given instance.</param>
            <param name="indexParameters">The index parameters to be used for setting the property value.</param>
            <exception cref="T:System.ArgumentException">
            <para>The type of the elements of the <paramref name="indexParameters"/> array does not match the index argument types expected by the
            property.</para>
            <para>-or-</para>
            <para>The set accessor cannot be found.</para>
            </exception>
            <exception cref="T:System.Reflection.TargetException">The <paramref name="instance"/> parameter is <see langword="null"/> although the property is not a static
            property or it does not match the property's declaring type.</exception>
            <exception cref="T:System.Reflection.TargetParameterCountException">The number of items in the <paramref name="indexParameters"/> array does not match the number
            of index parameters expected by the property.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">The property's get method throw an exception, see the <see cref="P:System.Exception.InnerException"/>
            property.</exception>
            <exception cref="T:System.MethodAccessException">The accessor was private or protected and could not be executed.</exception>
        </member>
        <member name="M:Remotion.Reflection.IPropertyInformation.GetGetMethod(System.Boolean)">
            <summary>
            Get the <see cref="T:Remotion.Reflection.IMethodInformation"/> of the get method for the current <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="nonPublic">Indicates whether a non-public accessor method may also be returned.</param>
            <returns>
            An instance of <see cref="T:Remotion.Reflection.IMethodInformation"/> for the get method.
            </returns>
        </member>
        <member name="M:Remotion.Reflection.IPropertyInformation.GetSetMethod(System.Boolean)">
            <summary>
            Get the <see cref="T:Remotion.Reflection.IMethodInformation"/> of the set method for the current <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="nonPublic">Indicates whether a non-public accessor method may also be returned.</param>
            <returns>
            An instance of <see cref="T:Remotion.Reflection.IMethodInformation"/> for the set method.
            </returns>
        </member>
        <member name="M:Remotion.Reflection.IPropertyInformation.FindInterfaceImplementation(System.Type)">
            <summary>
            Finds the implementation <see cref="T:Remotion.Reflection.IPropertyInformation"/> corresponding to this <see cref="T:Remotion.Reflection.IPropertyInformation"/> on the given 
            <see cref="T:System.Type"/>. This <see cref="T:Remotion.Reflection.IPropertyInformation"/> object must denote an interface property.
            </summary>
            <param name="implementationType">The type to search for an implementation of this <see cref="T:Remotion.Reflection.IPropertyInformation"/> on.</param>
            <returns>An instance of <see cref="T:Remotion.Reflection.IPropertyInformation"/> describing the property implementing this interface 
            <see cref="T:Remotion.Reflection.IPropertyInformation"/> on <paramref name="implementationType"/>, or <see langword="null"/> if the 
            <paramref name="implementationType"/> does not implement the interface.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="implementationType"/> is itself an interface.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:Remotion.Reflection.IPropertyInformation"/> does not describe an interface property.</exception>
        </member>
        <member name="M:Remotion.Reflection.IPropertyInformation.FindInterfaceDeclaration">
            <summary>
            Finds the interface declaration for this <see cref="T:Remotion.Reflection.IPropertyInformation"/>, returning <see langword="null"/> if this 
            <see cref="T:Remotion.Reflection.IPropertyInformation"/> is not an implementation of an interface member.
            </summary>
            <returns>An <see cref="T:Remotion.Reflection.IPropertyInformation"/> for the interface member this <see cref="T:Remotion.Reflection.IPropertyInformation"/> implements, or 
            <see langword="null"/> if this <see cref="T:Remotion.Reflection.IPropertyInformation"/> is not an implementation of an interface member.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:Remotion.Reflection.IPropertyInformation"/> is itself an interface member, so it cannot have an 
            interface declaration.</exception>
        </member>
        <member name="P:Remotion.Reflection.IPropertyInformation.PropertyType">
            <summary>
            Gets the type of the property, i.e. the type of values the property can store.
            </summary>
            <value>The type of the property.</value>
        </member>
        <member name="P:Remotion.Reflection.IPropertyInformation.CanBeSetFromOutside">
            <summary>
            Determines whether the property can be set from the outside.
            </summary>
            <value>True if this instance has can be set from the outside; otherwise, false.</value>
        </member>
        <member name="T:Remotion.Reflection.ParamList">
            <summary>
            Represents a strongly typed list of parameters to be passed to a function or action delegate.
            </summary>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``2(``0,``1)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``3(``0,``1,``2)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``4(``0,``1,``2,``3)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``5(``0,``1,``2,``3,``4)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``9(``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``10(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``11(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``12(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``13(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``14(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``15(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``16(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``17(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``18(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16,``17)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``19(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16,``17,``18)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``20(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16,``17,``18,``19)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create``1(``0)">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.Create">
            <summary>
            Returns an empty parameter list to be passed to a function or action.
            </summary>
            <returns>An empty <see cref="T:Remotion.Reflection.ParamList"/>. This is the same value returned by <see cref="P:Remotion.Reflection.ParamList.Empty"/>.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.CreateDynamic(System.Type[],System.Object[])">
            <summary>
            Creates a strongly typed list of parameters to be passed to a function or action.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.CreateDynamic(System.Object[])">
            <summary>
            Creates a list of parameters to be passed to a function or action. This overload takes a <c>params</c> array, which is convenient, but might
            lead to subtle bugs, especially when <see langword="null"/> values are supplied.
            </summary>
            <returns>A <see cref="T:Remotion.Reflection.ParamList"/> encapsulating the passed parameters.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.InvokeAction(System.Delegate)">
            <summary>
            Executes the given action delegate, passing in the parameters encapsulated by this <see cref="T:Remotion.Reflection.ParamList"/>.
            </summary>
            <param name="action">The action to be executed. This delegate must match <see cref="P:Remotion.Reflection.ParamList.ActionType"/>. If <see cref="P:Remotion.Reflection.ParamList.ActionType"/> is null,
            it must match the types returned by <see cref="M:Remotion.Reflection.ParamList.GetParameterTypes"/>.</param>
        </member>
        <member name="M:Remotion.Reflection.ParamList.InvokeFunc(System.Delegate)">
            <summary>
            Executes the given function delegate, passing in the parameters encapsulated by this <see cref="T:Remotion.Reflection.ParamList"/>.
            </summary>
            <param name="func">The function to be executed. This delegate must match <see cref="P:Remotion.Reflection.ParamList.FuncType"/>. If <see cref="P:Remotion.Reflection.ParamList.FuncType"/> is null,
            it must match the types returned by <see cref="M:Remotion.Reflection.ParamList.GetParameterTypes"/>, plus <see cref="T:System.Object"/> as the return type.</param>
            <returns>The result of the delegate execution.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.InvokeConstructor(Remotion.Reflection.IConstructorLookupInfo)">
            <summary>
            Executes a constructor, passing in the parameters encapsulated by this <see cref="T:Remotion.Reflection.ParamList"/>.
            </summary>
            <param name="constructorLookupInfo">An object looking up the constructor to be invoked. The lookup is performed with the signature defined 
            by the parameters encapsulated by this <see cref="T:Remotion.Reflection.ParamList"/>.</param>
            <returns>The result of the constructor invocation.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.GetParameterTypes">
            <summary>
            Gets the parameter types of the parameters encapsulated by this <see cref="T:Remotion.Reflection.ParamList"/>.
            </summary>
            <returns>The parameter types.</returns>
        </member>
        <member name="M:Remotion.Reflection.ParamList.GetParameterValues">
            <summary>
            Gets the parameter values of the parameters encapsulated by this <see cref="T:Remotion.Reflection.ParamList"/>.
            </summary>
            <returns>The parameter values.</returns>
        </member>
        <member name="P:Remotion.Reflection.ParamList.Empty">
            <summary>
            Represents an empty parameter list. This is equivalent to calling the <see cref="M:Remotion.Reflection.ParamList.Create"/> overload without parameters.
            </summary>
        </member>
        <member name="P:Remotion.Reflection.ParamList.FuncType">
            <summary>
            Gets the type of <see cref="T:System.Func`1"/> delegates supported by this <see cref="T:Remotion.Reflection.ParamList"/> instance.
            </summary>
            <value>The function delegate type supported by this <see cref="T:Remotion.Reflection.ParamList"/> instance.</value>
        </member>
        <member name="P:Remotion.Reflection.ParamList.ActionType">
            <summary>
            Gets the type of <see cref="T:System.Action"/> delegates supported by this <see cref="T:Remotion.Reflection.ParamList"/> instance.
            </summary>
            <value>The action delegate type supported by this <see cref="T:Remotion.Reflection.ParamList"/> instance.</value>
        </member>
        <member name="T:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility">
            <summary>
            Represents the central entry point into re-motion's type discovery mechanism. All components requiring type discovery should use this class and
            its <see cref="M:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.GetTypeDiscoveryService"/> method. All components retriving a type by its name that could be executed in the context of the
            designer should use <see cref="M:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.GetType(System.String,System.Boolean)"/>.
            </summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.GetTypeDiscoveryService">
            <summary>
            Gets the current context-specific <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/>. If <see cref="P:Remotion.Utilities.DesignerUtility.IsDesignMode"/> is set to 
            <see langword="true"/>, the designer's <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/> is returned. Otherwise, the 
            <see cref="P:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.DefaultNonDesignModeService"/> is returned. If no custom instance has been set for the <see cref="P:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.DefaultNonDesignModeService"/>
            property, <see cref="T:Remotion.Configuration.TypeDiscovery.TypeDiscoveryConfiguration"/> is used to create a new 
            <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/> when the property is first retrieved. That instance is stored for later uses.
            </summary>
            <value>The current context-specific <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/>.</value>
        </member>
        <member name="M:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.GetType(System.String,System.Boolean)">
            <summary>
            Gets a type by its name, agnostic of whether the code is executing in the designer or not. If <see cref="P:Remotion.Utilities.DesignerUtility.IsDesignMode"/>
            is set to <see langword="true"/>, the designer services are used to retrieve the type. Otherwise, <see cref="M:System.Type.GetType(System.String,System.Boolean)"/> is 
            used. Use <see cref="T:Remotion.Utilities.TypeUtility"/> in order to get types by an abbreviated type name.
            </summary>
            <param name="typeName">The name of the type to get. This must follow the conventions of <see cref="M:System.Type.GetType(System.String,System.Boolean)"/>.</param>
            <param name="throwOnError">If <see langword="true"/>, a <see cref="T:System.TypeLoadException"/> is thrown if the given type cannot be loaded.
            Otherwise, <see langword="null"/> is returned.</param>
            <returns>The type with the given name, retrieved either from the designer or via <see cref="M:System.Type.GetType(System.String,System.Boolean)"/>.</returns>
        </member>
        <member name="P:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.DefaultNonDesignModeService">
            <summary>
            Gets or sets the default non-design mode <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/>. This service is returned whenever 
            <see cref="M:Remotion.Reflection.TypeDiscovery.ContextAwareTypeDiscoveryUtility.GetTypeDiscoveryService"/> is called unless <see cref="P:Remotion.Utilities.DesignerUtility.IsDesignMode"/> is set to <see langword="true"/> (in which
            case the designer's <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/> is used instead). If no custom instance has been set for this property, 
            <see cref="T:Remotion.Configuration.TypeDiscovery.TypeDiscoveryConfiguration"/> is used to create a new <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/>
            when the property is first retrieved. That instance is stored for later uses.
            </summary>
            <value>The default non design mode <see cref="T:System.ComponentModel.Design.ITypeDiscoveryService"/>.</value>
        </member>
        <member name="T:Remotion.Reflection.IFuncInvoker`1">
            <summary>
            This interface allows invokers with fixed arguments to be returned without references to their generic argument types. 
            </summary>
            <remarks>
            <p>Note that casting a <see cref="T:Remotion.Reflection.FuncInvoker"/> struct to an interface is a boxing operation, thus creating an object on the
            heap and garbage collecting it later. For very performance-critical scenarios, it be better to avoid this and accept the references to 
            the invoker's generic argument types.</p>
            <p>It is recommended to wrap this interface within a <see cref="T:Remotion.Reflection.FuncInvokerWrapper`1"/>, because returning an interface could lead to 
            ambigous castings if the final call to <see cref="M:Remotion.Reflection.IFuncInvoker`1.With``1(``0)"/> is missing, while using structs will usually lead to a compile-time error as 
            expected.</p>
            </remarks>
            <typeparam name="TResult"> Return type of the method that will be invoked. </typeparam>
        </member>
        <member name="T:Remotion.Reflection.FuncInvokerWrapper`1">
            <summary>
            Used to wrap an <see cref="T:Remotion.Reflection.IFuncInvoker`1"/> object rather than returning it directly.
            </summary>
            <typeparam name="TResult"> Return type of the method that will be invoked. </typeparam>
        </member>
        <member name="T:Remotion.Reflection.IActionInvoker">
            <summary>
            This interface allows invokers with fixed arguments to be returned without references to their generic argument types. 
            </summary>
            <remarks>
            <p>Note that casting a <see cref="T:Remotion.Reflection.ActionInvoker"/> to an interface is a boxing operation, thus creating an object on the
            heap and garbage collecting it later. For very performance-critical scenarios, it be better to avoid this and accept the references to 
            the invoker's generic argument types.</p>
            <p>It is recommended to wrap this interface within a <see cref="T:Remotion.Reflection.ActionInvokerWrapper"/>, because returning an interface could lead to 
            ambigous castings if the final call to <see cref="M:Remotion.Reflection.IActionInvoker.With``1(``0)"/> is missing, while using structs will usually lead to a compile-time error as 
            expected.</p>
            </remarks>
        </member>
        <member name="T:Remotion.Reflection.ActionInvokerWrapper">
            <summary>
            Used to wrap an <see cref="T:Remotion.Reflection.IActionInvoker"/> object rather than returning it directly.
            </summary>
        </member>
        <member name="T:Remotion.Reflection.IConstructorLookupInfo">
            <summary>
            Represents an object that can be used to lookup and dynamically invoke constructors of a specific defining type.
            </summary>
        </member>
        <member name="T:Remotion.ServiceLocation.SafeServiceLocator">
            <summary>
            <see cref="T:Remotion.ServiceLocation.SafeServiceLocator"/> is intended as a wrapper for <see cref="T:Microsoft.Practices.ServiceLocation.ServiceLocator"/>, specifically the 
            <see cref="P:Microsoft.Practices.ServiceLocation.ServiceLocator.Current"/> property. In contrast to <see cref="T:Microsoft.Practices.ServiceLocation.ServiceLocator"/>, <see cref="T:Remotion.ServiceLocation.SafeServiceLocator"/> will never throw
            a <see cref="T:System.NullReferenceException"/> but instead register an instance of the DefaultServiceLocatorClass if no custom service locator was
            registered.
            </summary>
            <remarks>
            Accessing <see cref="T:Microsoft.Practices.ServiceLocation.ServiceLocator"/> will always lead to a <see cref="T:System.NullReferenceException"/> if no service locator is 
            configured. Using <see cref="T:Remotion.ServiceLocation.SafeServiceLocator"/> instead will catch the exception and register an instance of the DefaultServiceLocator class.
            </remarks>
        </member>
        <member name="P:Remotion.ServiceLocation.SafeServiceLocator.Current">
            <summary>
            Gets the currently configured <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator"/>. 
            If no service locator is configured or <see cref="P:Microsoft.Practices.ServiceLocation.ServiceLocator.Current"/> returns <see langword="null"/>, 
            an <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator"/> will be returned.
            </summary>
        </member>
        <member name="T:Remotion.Action`5">
            <summary>
            Provides a standard delegate type for an action without return value
            </summary>
        </member>
        <member name="T:Remotion.Action`6">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`7">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`8">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`9">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`10">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`11">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`12">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`13">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`14">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`15">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`16">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`17">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`18">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`19">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Action`20">
            <summary>
            Provides a standard delegate type for an action without return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`6">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`7">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`8">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`9">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`10">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`11">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`12">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`13">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`14">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`15">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`16">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`17">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`18">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`19">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`20">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.Func`21">
            <summary>
            Provides a standard delegate type for a function with a return value.
            </summary>
        </member>
        <member name="T:Remotion.SuppressAttributesAttribute">
            <summary>
            When applied to a class, causes certain custom attributes to be filtered out by 
            <see cref="M:Remotion.Utilities.AttributeUtility.GetCustomAttributes(System.Type,System.Type,System.Boolean)"/> and 
            <see cref="M:Remotion.Utilities.AttributeUtility.IsDefined(System.Reflection.MemberInfo,System.Type,System.Boolean)"/>.
            </summary>
            <remarks>
            All attributes of the given base type or derived from it are filtered unless they are declared on the same level as the 
            <see cref="T:Remotion.SuppressAttributesAttribute"/>. Consider the following example:
            <example>
            <code>
            [A ("Base")]
            [B ("Base")]
            [C ("Base")]
            class Base
            {
            }
            
            [A ("Derived")]
            [B ("Derived")]
            [C ("Derived")]
            [SuppressAttributes (typeof (A))]
            class Derived : Base
            {
            }
            
            [A ("DerivedDerived")]
            [B ("DerivedDerived")]
            [C ("DerivedDerived")]
            class DerivedDerived : Derived
            {
            }
            
            class A : Attribute { ... }
            class B : A { ... }
            class C : Attribute { ... }
            </code>
            <para>
            In this example, a call to GetCustomAttributes on typeof (DerivedDerived) would yield the following attributes:
            [C ("Base"), A ("Derived"), B ("Derived"), C ("Derived"), C ("DerivedDerived")].
            </para>
            <para>
            [A ("Base")] and [A ("DerivedDerived")] are suppressed due
            to the <see cref="T:Remotion.SuppressAttributesAttribute"/> on Derived's declaration. [B ("Base")] and [B ("DerivedDerived")] are also suppressed, because
            they inherit from A, which is suppressed. The C attributes are not suppressed because they are not related to A; [A ("Derived")] and 
            [B ("Derived")] are not suppressed because they are declared on the same level as the <see cref="T:Remotion.SuppressAttributesAttribute"/>.
            </para>
            Do not suppress instances of <see cref="T:Remotion.SuppressAttributesAttribute"/>.
            </example>
            </remarks>
        </member>
        <member name="T:Remotion.Utilities.ArgumentEmptyException">
            <summary>
            This exception is thrown if an argument is empty although it must have a content.
            </summary>
        </member>
        <member name="T:Remotion.Utilities.ArgumentItemNullException">
            <summary>
            This exception is thrown if a list argument contains a null reference.
            </summary>
        </member>
        <member name="T:Remotion.Utilities.ArgumentItemTypeException">
            <summary>
            This exception is thrown if a list argument contains an item of the wrong type.
            </summary>
        </member>
        <member name="T:Remotion.Utilities.ArgumentTypeException">
            <summary>
            This exception is thrown if an argument has an invalid type.
            </summary>
        </member>
        <member name="T:Remotion.Utilities.ArgumentItemDuplicateException">
            <summary>
            This exception is thrown if a list argument contains duplicates.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:JetBrains.Annotations.AssertionMethodAttribute"/> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
            <seealso cref="T:JetBrains.Annotations.AssertionConditionType"/>
        </member>
        <member name="M:JetBrains.Annotations.AssertionConditionAttribute.#ctor(JetBrains.Annotations.AssertionConditionType)">
            <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
            <param name="conditionType">Specifies condition type</param>
        </member>
        <member name="P:JetBrains.Annotations.AssertionConditionAttribute.ConditionType">
            <summary>
            Gets condition type
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:JetBrains.Annotations.AssertionConditionAttribute"/> attribute
            </summary>
            <seealso cref="T:JetBrains.Annotations.AssertionConditionAttribute"/>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException"/> has such parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> -like form
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
            <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        </member>
        <member name="P:JetBrains.Annotations.StringFormatMethodAttribute.FormatParameterName">
            <summary>
            Gets format parameter name
            </summary>
        </member>
    </members>
</doc>
